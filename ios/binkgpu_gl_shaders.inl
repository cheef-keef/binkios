// Copyright Epic Games, Inc. All Rights Reserved.
// This file was automatically generated by shadergen. Do not edit by hand!

static char const shader_source_frag0[] =
  "#version 430 core\n"
  "#define OUT_PARA(type, name) out type name\n"
  "#define INOUT_PARA(type, name) inout type name\n"
  "#define SHARED_GLOBAL(type, name) shared type name\n"
  "#define U0(field) field\n"
  "#define U1(field) field\n"
  "#define LOCALFUNC\n"
  "#define METAL_ARG(arg)\n"
  "#define COMPUTE_SHADER_MAIN(dimx, dimy, dimz) layout(local_size_x=dimx, local_size_y=dimy, local_size_z=dimz) in; void main()\n"
  "#define UNIFORM_BUFFER(name, bindidx) layout(std140, binding=bindidx) uniform name\n"
  "#define DECLARE_SAMPLER_IBUF(bindidx, type, name) layout(binding=bindidx) uniform isamplerBuffer name\n"
  "#define DECLARE_SAMPLER_U2D(bindidx, name) layout(binding=bindidx) uniform usampler2D name\n"
  "#define DECLARE_SAMPLER_U2D_GATHER(bindidx, name) layout(binding=bindidx) uniform usampler2D name\n"
  "#define DECLARE_IMAGE_R16I_BUF(bindidx, name) layout(binding=bindidx, r16i) uniform iimageBuffer name\n"
  "#define DECLARE_IMAGE_R32I_BUF(bindidx, name) layout(binding=bindidx, r32i) uniform iimageBuffer name\n"
  "#define DECLARE_IMAGE_RG32I_BUF(bindidx, name) layout(binding=bindidx, rg32i) uniform iimageBuffer name\n"
  "#define DECLARE_IMAGE_RGBA32I_BUF(bindidx, name) layout(binding=bindidx, rgba32i) uniform iimageBuffer name\n"
  "#define DECLARE_IMAGE_R8UI_2D(bindidx, name) layout(binding=bindidx, r8ui) uniform uimage2D name\n"
  "#define DECLARE_IMAGE_RG8UI_2D(bindidx, name) layout(binding=bindidx, rg8ui) uniform uimage2D name\n"
  "#define ROOT_SIGNATURE(sig)\n"
  "#define NEED_DC_COPY\n"
  "#define DC_WRITE_OFFS 0\n"
  "#define imageLoad_buf_i2(img, pos) (imageLoad(img, int(pos)).xy)\n"
  "#define imageLoad_buf_i4(img, pos) imageLoad(img, int(pos))\n"
  "#define imageStore_u1(img, pos, val)  imageStore((img), ivec2(pos), uvec4(val))\n"
  "#define imageStore_u2(img, pos, vals) imageStore((img), ivec2(pos), uvec4((vals).xyxy))\n"
  "#define imageStore_buf_i1(img, pos, val)  imageStore((img), int(pos), ivec4(val))\n"
  "#define imageStore_buf_i1s(img, pos, val) imageStore_buf_i1((img), (pos), (val))\n"
  "#define imageStore_buf_i2(img, pos, vals) imageStore((img), int(pos), ivec4((vals).xyxy))\n"
  "#define imageStore_buf_i4(img, pos, vals) imageStore((img), int(pos), ivec4((vals)))\n"
  "#define bufferFetch(buf, offs) texelFetch((buf), int(offs))\n"
  "#define texelOrImageFetch(tex, image, pos) texelFetch((tex), (pos), 0)\n"
  "#define imul24(a,b) ((a)*(b))\n"
  "#define pack16(a,b) bitfieldInsert((a), (b), 16, 16)\n"
  "#define bitSelect(mask,a,b) (((mask) & (a)) | (~(mask) & (b)))\n"
  "#define atomicLoad(a) (a)\n"
  "#define atomicStore(a, b) (a)=(b)\n"
  "#define group_sync() groupMemoryBarrier(); barrier()\n";
static char const shader_source_frag1[] =  "";
static char const shader_source_frag2[] =
  "#define MAX_WIDTH32 512\n"
  "#define MININTRA 0\n"
  "#define MAXINTRA 2047\n"
  "#define BINKGPUDEBLOCKUD    0x0001\n"
  "#define BINKGPUDEBLOCKLR    0x0002\n"
  "#define BINKGPUNEWCLAMP     0x0004\n"
  "#define BINKGPUBINK24       0x0008\n"
  "#define BINKGPUCONSTANTA    0x0010\n";
static char const shader_source_frag3[] =
  "UNIFORM_BUFFER(frame_consts, 0) {\n"
  "uint frame_flags;\n"
  "uint fill_alpha_value;\n"
  "uvec2 size_in_blocks;\n"
  "uvec4 dc_offsets;\n"
  "uvec4 dc_offsets2;\n"
  "uint dc_bias;\n"
  "uint dc_max;\n"
  "uint cb_offs_ac;\n"
  "uint cb_offs_dc;\n"
  "uvec2 max_offs_full;\n"
  "uvec2 max_offs_sub;\n"
  "vec4 luma_tex_scale_offs;\n"
  "ivec4 mv_x_clamp;\n"
  "ivec4 mv_y_clamp;\n"
  "uvec4 flags[(MAX_WIDTH32*4 + 31)/32];\n"
  "};\n"
  "UNIFORM_BUFFER(deblock_consts, 1) {\n"
  "uvec2 dir_mask;\n"
  "uint row_inc_full;\n"
  "uint row_inc_sub;\n"
  "};\n";
static char const shader_source_frag4[] =
  "DECLARE_SAMPLER_IBUF(0, int1, zigzag8);\n"
  "DECLARE_SAMPLER_IBUF(1, int1, coeff_data);\n"
  "DECLARE_SAMPLER_IBUF(2, int1, dc_data);\n"
  "#ifdef MOTION\n"
  "#ifdef SUB_PLANE\n"
  "DECLARE_SAMPLER_U2D(3, i_img);\n"
  "#else\n"
  "DECLARE_SAMPLER_U2D_GATHER(3, i_img);\n"
  "#endif\n"
  "DECLARE_SAMPLER_IBUF(4, ivec2, motion_buf);\n"
  "DECLARE_IMAGE_R16I_BUF(1, dc_out_buf);\n"
  "#endif\n"
  "#ifdef SUB_PLANE\n"
  "#define BLOCKS_PER_MB   4\n"
  "#define BLOCKS_TOTAL    8\n"
  "#define RESIDUAL_W      32\n"
  "#define RESIDUAL_H      16\n"
  "#define MASK_LOW_X      1\n"
  "#define MASK_LOW_Y      2\n"
  "#define MASK_BLOCK      ~3\n"
  "#define MB_EDGE_LEN     16\n"
  "#define METAL_INTEXTYPE ushort\n"
  "DECLARE_IMAGE_RG8UI_2D(0, o_img);\n"
  "#else\n"
  "#define BLOCKS_PER_MB   16\n"
  "#define BLOCKS_TOTAL    16\n"
  "#define RESIDUAL_W      32\n"
  "#define RESIDUAL_H      32\n"
  "#define MASK_LOW_X      0x5\n"
  "#define MASK_LOW_Y      0xa\n"
  "#define MASK_BLOCK      ~0xf\n"
  "#define MB_EDGE_LEN     32\n"
  "#define METAL_INTEXTYPE half\n"
  "DECLARE_IMAGE_R8UI_2D(0, o_img);\n"
  "#endif\n"
  "#define METAL_ARGD \\\n"
  "METAL_ARG(constant frame_consts& u0) \\\n"
  "METAL_ARG(device short1 *zigzag8) METAL_ARG(device int1 *coeff_data) METAL_ARG(device short1 *dc_data) \\\n"
  "METAL_ARG(texture2d<METAL_INTEXTYPE> i_img) METAL_ARG(rwtexture2d_ushort o_img) \\\n"
  "METAL_ARG(device short2 *motion_buf) METAL_ARG(device short1 *dc_out_buf) \\\n"
  "METAL_ARG(threadgroup uvec2 *ac_nonzero) METAL_ARG(threadgroup int *coeffs) \\\n"
  "METAL_ARG(threadgroup uint *dcf_linear) METAL_ARG(threadgroup volatile atomic_uint *dcf_atomic) \\\n"
  "METAL_ARG(threadgroup ivec2 *motion_vecs) METAL_ARG(threadgroup int *residual)\n"
  "#define METAL_ARGS \\\n"
  "METAL_ARG(u0) \\\n"
  "METAL_ARG(zigzag8) METAL_ARG(coeff_data) METAL_ARG(dc_data) \\\n"
  "METAL_ARG(i_img) METAL_ARG(o_img) \\\n"
  "METAL_ARG(motion_buf) METAL_ARG(dc_out_buf) \\\n"
  "METAL_ARG(ac_nonzero) METAL_ARG(coeffs) \\\n"
  "METAL_ARG(dcf_linear) METAL_ARG(dcf_atomic) \\\n"
  "METAL_ARG(motion_vecs) METAL_ARG(residual)\n"
  "LOCALFUNC uint morton_decode(uint x)\n"
  "{\n"
  "return (x & 1) | ((x >> 1) & 2);\n"
  "}\n"
  "LOCALFUNC int get_dc(uint offs METAL_ARGD)\n"
  "{\n"
  "return bufferFetch(dc_data, offs).x;\n"
  "}\n"
  "LOCALFUNC int coeff_data_v(uint offs METAL_ARGD)\n"
  "{\n"
  "return bufferFetch(coeff_data, offs).x;\n"
  "}\n"
  "#ifndef METAL_LANG\n"
  "LOCALFUNC int get_int16(uint ptr)\n"
  "{\n"
  "int val_pair = coeff_data_v(ptr >> 1);\n"
  "return bitfieldExtract(val_pair, int(ptr & 1) << 4, 16);\n"
  "}\n"
  "#else\n"
  "LOCALFUNC int get_int16(uint ptr METAL_ARGD)\n"
  "{\n"
  "return ((device short *) coeff_data)[ptr];\n"
  "}\n"
  "#endif\n"
  "LOCALFUNC bool fetch_residual_ptr(OUT_PARA(uint, ptr), uint flat_id, uint invoc METAL_ARGD)\n"
  "{\n"
  "#ifdef SUB_PLANE\n"
  "uint ptr_cr = uint(coeff_data_v(flat_id METAL_ARGS)) * 2;\n"
  "uint ptr_cb = uint(coeff_data_v(flat_id + U0(cb_offs_ac) METAL_ARGS)) * 2;\n"
  "if (ptr_cb != 0)\n"
  "ptr_cb += U0(cb_offs_ac)*2;\n"
  "bool has_residuals = (ptr_cr | ptr_cb) != 0;\n"
  "ptr = (invoc < 32) ? ptr_cr : ptr_cb;\n"
  "#else\n"
  "ptr = uint(coeff_data_v(flat_id METAL_ARGS)) * 2;\n"
  "bool has_residuals = ptr != 0;\n"
  "#endif\n"
  "return has_residuals;\n"
  "}\n"
  "#define MASK_ALL_X (MASK_LOW_X | MASK_BLOCK)\n"
  "#define MASK_ALL_Y (MASK_LOW_Y | MASK_BLOCK)\n"
  "LOCALFUNC int dc_threshold(int in_dc, uint bias_rel, int replace_dc, uint dc_max)\n"
  "{\n"
  "return (uint(in_dc) + bias_rel) >= dc_max ? replace_dc : in_dc;\n"
  "}\n"
  "LOCALFUNC int dc_horiz_filter(int lft, int mid, int rgt, uint lane)\n"
  "{\n"
  "int shift = int(min(lane, 7-lane)) * 8;\n"
  "ivec2 weights = bitfieldExtract(ivec2(int(0x0e182434), int(0x08040100)), shift, 8);\n"
  "weights = (lane < 4) ? weights.xy : weights.yx;\n"
  "mid &= 0x1fff;\n"
  "lft = (lft & 0x1fff) - mid;\n"
  "rgt = (rgt & 0x1fff) - mid;\n"
  "return mid + (imul24(lft, weights.x) >> 7) + (imul24(rgt, weights.y) >> 7);\n"
  "}\n"
  "LOCALFUNC int dc_tap0(int mid, int near, int far) { return mid + (imul24(13, near) >> 5); }\n"
  "LOCALFUNC int dc_tap1(int mid, int near, int far) { return mid + (imul24( 9, near) >> 5) + (far >> 7); }\n"
  "LOCALFUNC int dc_tap2(int mid, int near, int far) { return mid + (imul24( 3, near) >> 4) + (far >> 5); }\n"
  "LOCALFUNC int dc_tap3(int mid, int near, int far) { return mid + (imul24( 7, near) >> 6) + (far >> 4); }\n"
  "LOCALFUNC void dc_vert_filter(OUT_PARA(ivec4, o0), OUT_PARA(ivec4, o1), int top, int mid, int bot)\n"
  "{\n"
  "top -= mid;\n"
  "bot -= mid;\n"
  "mid += 4;\n"
  "o0.x = dc_tap0(mid, top, bot);\n"
  "o0.y = dc_tap1(mid, top, bot);\n"
  "o0.z = dc_tap2(mid, top, bot);\n"
  "o0.w = dc_tap3(mid, top, bot);\n"
  "o1.x = dc_tap3(mid, bot, top);\n"
  "o1.y = dc_tap2(mid, bot, top);\n"
  "o1.z = dc_tap1(mid, bot, top);\n"
  "o1.w = dc_tap0(mid, bot, top);\n"
  "}\n"
  "LOCALFUNC void int_full_blur(OUT_PARA(ivec4, o0), OUT_PARA(ivec4, o1), int dc11, uint group_id, uint lane_id, uvec2 work_group_id METAL_ARGD)\n"
  "{\n"
  "#ifdef SUB_PLANE\n"
  "uint block_id = group_id & 3;\n"
  "uint dc_offs = (group_id >= BLOCKS_PER_MB) ? U0(cb_offs_dc) : 0;\n"
  "int last_row_start = int(U0(max_offs_sub).y) | MASK_LOW_Y;\n"
  "#else\n"
  "uint block_id = group_id;\n"
  "uint dc_offs = 0;\n"
  "int last_row_start = int(U0(max_offs_full).y) | MASK_LOW_Y;\n"
  "#endif\n"
  "uint x_offs_mid = work_group_id.x * BLOCKS_PER_MB + (block_id & MASK_LOW_X);\n"
  "uint y_offs_mid = work_group_id.y * (U0(size_in_blocks).x * BLOCKS_PER_MB) + (block_id & MASK_LOW_Y);\n"
  "uint x_offs_lft = (x_offs_mid - 1) & MASK_ALL_X;\n"
  "uint x_offs_rgt = (x_offs_mid - MASK_ALL_X) & MASK_ALL_X;\n"
  "int x_mask_lft = -1, x_mask_rgt = -1;\n"
  "uint x_max = U0(size_in_blocks).x * BLOCKS_PER_MB;\n"
  "if (x_offs_lft >= x_max)\n"
  "{\n"
  "x_offs_lft = x_offs_mid;\n"
  "x_mask_lft = 0;\n"
  "}\n"
  "if (x_offs_rgt >= x_max)\n"
  "{\n"
  "x_offs_rgt = x_offs_mid;\n"
  "x_mask_rgt = 0;\n"
  "}\n"
  "uint y_offs_top = (y_offs_mid - 2) & MASK_ALL_Y;\n"
  "uint y_offs_bot = (y_offs_mid - MASK_ALL_Y) & MASK_ALL_Y;\n"
  "uint row_offs = x_max - BLOCKS_PER_MB;\n"
  "y_offs_top -= ((y_offs_top & MASK_LOW_Y) == MASK_LOW_Y) ? row_offs : 0;\n"
  "y_offs_bot += ((y_offs_bot & MASK_LOW_Y) == 0) ? row_offs : 0;\n"
  "y_offs_top = uint(max(int(y_offs_top), 0));\n"
  "y_offs_bot = uint(min(int(y_offs_bot), last_row_start));\n"
  "y_offs_top += dc_offs;\n"
  "y_offs_mid += dc_offs;\n"
  "y_offs_bot += dc_offs;\n"
  "uint bias_rel = U0(dc_bias) - uint(dc11);\n"
  "int dc01 = dc_threshold(get_dc(x_offs_lft + y_offs_mid METAL_ARGS) & x_mask_lft, bias_rel, dc11, U0(dc_max));\n"
  "int dc21 = dc_threshold(get_dc(x_offs_rgt + y_offs_mid METAL_ARGS) & x_mask_rgt, bias_rel, dc11, U0(dc_max));\n"
  "int dc00 = dc_threshold(get_dc(x_offs_lft + y_offs_top METAL_ARGS) & x_mask_lft, bias_rel, dc01, U0(dc_max));\n"
  "int dc10 = dc_threshold(get_dc(x_offs_mid + y_offs_top METAL_ARGS), bias_rel, dc11, U0(dc_max));\n"
  "int dc20 = dc_threshold(get_dc(x_offs_rgt + y_offs_top METAL_ARGS) & x_mask_rgt, bias_rel, dc21, U0(dc_max));\n"
  "int dc02 = dc_threshold(get_dc(x_offs_lft + y_offs_bot METAL_ARGS) & x_mask_lft, bias_rel, dc01, U0(dc_max));\n"
  "int dc12 = dc_threshold(get_dc(x_offs_mid + y_offs_bot METAL_ARGS), bias_rel, dc11, U0(dc_max));\n"
  "int dc22 = dc_threshold(get_dc(x_offs_rgt + y_offs_bot METAL_ARGS) & x_mask_rgt, bias_rel, dc21, U0(dc_max));\n"
  "int top = dc_horiz_filter(dc00, dc10, dc20, lane_id);\n"
  "int mid = dc_horiz_filter(dc01, dc11, dc21, lane_id);\n"
  "int bot = dc_horiz_filter(dc02, dc12, dc22, lane_id);\n"
  "dc_vert_filter(o0, o1, top, mid, bot);\n"
  "}\n"
  "SHARED_GLOBAL(uvec2, ac_nonzero[BLOCKS_TOTAL]);\n"
  "SHARED_GLOBAL(int, coeffs[64*8]);\n"
  "SHARED_GLOBAL(uint, dcf_linear[BLOCKS_TOTAL]);\n"
  "#ifdef SEPARATE_DCF_ATOMIC\n"
  "SHARED_GLOBAL(uint, dcf_atomic[BLOCKS_TOTAL]);\n"
  "#else\n"
  "#define dcf_atomic dcf_linear\n"
  "#endif\n"
  "LOCALFUNC uint decode_flags(uint ptr, uint lane METAL_ARGD)\n"
  "{\n"
  "#ifdef SUB_PLANE\n"
  "uint i = lane & 31;\n"
  "uint out_idx = (lane & 3) | ((lane & 32) >> 3);\n"
  "#else\n"
  "uint i = lane;\n"
  "uint out_idx = i;\n"
  "#endif\n"
  "uint block_flags = 0;\n"
  "if (ptr != 0)\n"
  "{\n"
  "block_flags = uint(coeff_data_v(ptr >> 1 METAL_ARGS));\n"
  "ptr += 2;\n"
  "}\n"
  "if (i < BLOCKS_PER_MB)\n"
  "{\n"
  "uvec2 nonzero_mask = uvec2(0, 0);\n"
  "uint lane_mask = 1u << i;\n"
  "if ((block_flags & lane_mask) != 0)\n"
  "{\n"
  "uint idx = bitCount(block_flags & (lane_mask - 1));\n"
  "uint fetch_offs = (ptr >> 1) + idx*2;\n"
  "nonzero_mask = uvec2(coeff_data_v(fetch_offs + 0 METAL_ARGS), coeff_data_v(fetch_offs + 1 METAL_ARGS));\n"
  "}\n"
  "ac_nonzero[out_idx] = nonzero_mask;\n"
  "}\n"
  "ptr += 4 * bitCount(block_flags);\n"
  "return ptr;\n"
  "}\n"
  "LOCALFUNC void load8_strided(OUT_PARA(ivec4, o0), OUT_PARA(ivec4, o1), uint offs, uint stride METAL_ARGD)\n"
  "{\n"
  "o0.x = coeffs[offs]; offs += stride;\n"
  "o0.y = coeffs[offs]; offs += stride;\n"
  "o0.z = coeffs[offs]; offs += stride;\n"
  "o0.w = coeffs[offs]; offs += stride;\n"
  "o1.x = coeffs[offs]; offs += stride;\n"
  "o1.y = coeffs[offs]; offs += stride;\n"
  "o1.z = coeffs[offs]; offs += stride;\n"
  "o1.w = coeffs[offs];\n"
  "}\n"
  "LOCALFUNC void store8_strided(uint offs, uint stride, ivec4 i0, ivec4 i1 METAL_ARGD)\n"
  "{\n"
  "coeffs[offs] = i0.x; offs += stride;\n"
  "coeffs[offs] = i0.y; offs += stride;\n"
  "coeffs[offs] = i0.z; offs += stride;\n"
  "coeffs[offs] = i0.w; offs += stride;\n"
  "coeffs[offs] = i1.x; offs += stride;\n"
  "coeffs[offs] = i1.y; offs += stride;\n"
  "coeffs[offs] = i1.z; offs += stride;\n"
  "coeffs[offs] = i1.w;\n"
  "}\n"
  "LOCALFUNC void int_idct(INOUT_PARA(ivec4, x0), INOUT_PARA(ivec4, x1))\n"
  "{\n"
  "int c0 = x0.x;\n"
  "int c1 = x1.x;\n"
  "int c2 = x0.z;\n"
  "int c3 = x1.z;\n"
  "int c4 = x0.y;\n"
  "int d5 = x1.y;\n"
  "int c6 = x1.w;\n"
  "int d7 = x0.w;\n"
  "int c5 = d7 + d5;\n"
  "int c7 = d7 - d5;\n"
  "int b4 = c4 + c5;\n"
  "int b5 = c4 - c5;\n"
  "int b6 = c7 - c6;\n"
  "int b7 = c7 + c6;\n"
  "int a4 = (b7 >> 2) + (b4 + (b4 >> 2) - (b4 >> 4));\n"
  "int a7 = (b4 >> 2) - (b7 + (b7 >> 2) - (b7 >> 4));\n"
  "int a5 = (b6 - (b6 >> 2) - (b6 >> 4)) + b5;\n"
  "int a6 = (b5 - (b5 >> 2) - (b5 >> 4)) - b6;\n"
  "int b0 = c0 + c1;\n"
  "int b1 = c0 - c1;\n"
  "int b2 = (c3 >> 1) + (c2 + (c2 >> 2));\n"
  "int b3 = (c2 >> 1) - (c3 + (c3 >> 2));\n"
  "int a0 = b0 + b2;\n"
  "int a1 = b1 + b3;\n"
  "int a2 = b1 - b3;\n"
  "int a3 = b0 - b2;\n"
  "x0.x = a0 + a4;\n"
  "x0.y = a1 + a5;\n"
  "x0.z = a2 + a6;\n"
  "x0.w = a3 + a7;\n"
  "x1.x = a3 - a7;\n"
  "x1.y = a2 - a6;\n"
  "x1.z = a1 - a5;\n"
  "x1.w = a0 - a4;\n"
  "}\n"
  "LOCALFUNC void idct_2d(OUT_PARA(ivec4, t0), OUT_PARA(ivec4, t1), uint rel_block_id, uint row_col_id, uint block_id, uvec2 work_group_id METAL_ARGD)\n"
  "{\n"
  "#ifdef MOTION\n"
  "uint row_idct_offs = rel_block_id + row_col_id * 64;\n"
  "load8_strided(t0, t1, row_idct_offs, 8 METAL_ARGS);\n"
  "int_idct(t0, t1);\n"
  "group_sync();\n"
  "store8_strided(row_idct_offs, 8, t0, t1 METAL_ARGS);\n"
  "group_sync();\n"
  "uint col_idct_offs = rel_block_id + row_col_id * 8;\n"
  "load8_strided(t0, t1, col_idct_offs, 64 METAL_ARGS);\n"
  "int_idct(t0, t1);\n"
  "t0 = bitfieldExtract(t0, 0, 16);\n"
  "t1 = bitfieldExtract(t1, 0, 16);\n"
  "t0 >>= 6;\n"
  "t1 >>= 6;\n"
  "#else\n"
  "uint dc11 = dcf_linear[rel_block_id];\n"
  "bool run_full_blur = (dc11 & 0xffff) >= 0xe000;\n"
  "{\n"
  "uint row_idct_offs = 0;\n"
  "t0 = t1 = ivec4(0,0,0,0);\n"
  "if (!run_full_blur)\n"
  "{\n"
  "row_idct_offs = rel_block_id + row_col_id * 64;\n"
  "load8_strided(t0, t1, row_idct_offs, 8 METAL_ARGS);\n"
  "int_idct(t0, t1);\n"
  "}\n"
  "group_sync();\n"
  "if (!run_full_blur)\n"
  "{\n"
  "store8_strided(row_idct_offs, 8, t0, t1 METAL_ARGS);\n"
  "}\n"
  "}\n"
  "group_sync();\n"
  "#ifdef DUMMY_IF_BEFORE_FULLBLUR\n"
  "if (work_group_id.y > MAX_WIDTH32)\n"
  "run_full_blur = false;\n"
  "#endif\n"
  "if (!run_full_blur)\n"
  "{\n"
  "uint col_idct_offs = rel_block_id + row_col_id * 8;\n"
  "load8_strided(t0, t1, col_idct_offs, 64 METAL_ARGS);\n"
  "int_idct(t0, t1);\n"
  "}\n"
  "else\n"
  "int_full_blur(t0, t1, int(dc11), block_id, row_col_id, work_group_id METAL_ARGS);\n"
  "int shift_amt = run_full_blur ? 3 : 6;\n"
  "t0 >>= shift_amt;\n"
  "t1 >>= shift_amt;\n"
  "#endif\n"
  "}\n"
  "#ifdef MOTION\n"
  "SHARED_GLOBAL(int, residual[RESIDUAL_W*RESIDUAL_H/2]);\n"
  "#define RESIDUAL_OFFS(x,halfy) ((x) + (halfy)*RESIDUAL_W)\n"
  "LOCALFUNC int pack_res(ivec2 v)\n"
  "{\n"
  "return bitfieldInsert(v.x, v.y, 16, 16);\n"
  "}\n"
  "LOCALFUNC ivec2 unpack_res(int x)\n"
  "{\n"
  "return ivec2(bitfieldExtract(x, 0, 16), bitfieldExtract(x, 16, 16));\n"
  "}\n"
  "LOCALFUNC void store_residual_col(uint col_id, uint block_id, ivec4 t0, ivec4 t1, uint invoc, uvec2 work_group_id METAL_ARGD)\n"
  "{\n"
  "uvec2 block_xy = uvec2(morton_decode(block_id >> 0), morton_decode(block_id >> 1)) * 8;\n"
  "uint offs = RESIDUAL_OFFS(block_xy.x + col_id, block_xy.y >> 1);\n"
  "residual[offs + RESIDUAL_OFFS(0,0)] = pack_res(t0.xy);\n"
  "residual[offs + RESIDUAL_OFFS(0,1)] = pack_res(t0.zw);\n"
  "residual[offs + RESIDUAL_OFFS(0,2)] = pack_res(t1.xy);\n"
  "residual[offs + RESIDUAL_OFFS(0,3)] = pack_res(t1.zw);\n"
  "}\n"
  "#else\n"
  "LOCALFUNC void store_residual_col(uint col_id, uint block_id, ivec4 t0, ivec4 t1, uint invoc, uvec2 work_group_id METAL_ARGD)\n"
  "{\n"
  "t0 = clamp(t0, 0, 255);\n"
  "t1 = clamp(t1, 0, 255);\n"
  "#ifdef SUB_PLANE\n"
  "group_sync();\n"
  "store8_strided(block_id + col_id * 8, 64, t0, t1 METAL_ARGS);\n"
  "group_sync();\n"
  "uint store_block_id = (invoc >> 0) & 3;\n"
  "uint store_col      = (invoc >> 2) & 7;\n"
  "uint store_row      = (invoc >> 3) & 4;\n"
  "uint fetch_offs = (invoc & 3) | ((invoc << 1) & 0x38) | ((invoc << 3) & 0x100);\n"
  "t0.x = coeffs[fetch_offs + 0]; t1.x = coeffs[fetch_offs + 4]; fetch_offs += 64;\n"
  "t0.y = coeffs[fetch_offs + 0]; t1.y = coeffs[fetch_offs + 4]; fetch_offs += 64;\n"
  "t0.z = coeffs[fetch_offs + 0]; t1.z = coeffs[fetch_offs + 4]; fetch_offs += 64;\n"
  "t0.w = coeffs[fetch_offs + 0]; t1.w = coeffs[fetch_offs + 4];\n"
  "uvec2 block_xy = uvec2(store_block_id & 1, store_block_id >> 1) * 8;\n"
  "uvec2 out_col_pos = work_group_id.xy * MB_EDGE_LEN + block_xy + uvec2(store_col, store_row);\n"
  "imageStore_u2(o_img, out_col_pos + uvec2(0,0), uvec2(t0.x, t1.x));\n"
  "imageStore_u2(o_img, out_col_pos + uvec2(0,1), uvec2(t0.y, t1.y));\n"
  "imageStore_u2(o_img, out_col_pos + uvec2(0,2), uvec2(t0.z, t1.z));\n"
  "imageStore_u2(o_img, out_col_pos + uvec2(0,3), uvec2(t0.w, t1.w));\n"
  "#else\n"
  "uvec2 block_xy = uvec2(morton_decode(block_id >> 0), morton_decode(block_id >> 1)) * 8;\n"
  "uvec2 out_col_pos = work_group_id.xy * MB_EDGE_LEN + block_xy + uvec2(col_id, 0);\n"
  "imageStore_u1(o_img, out_col_pos + uvec2(0,0), t0.x);\n"
  "imageStore_u1(o_img, out_col_pos + uvec2(0,1), t0.y);\n"
  "imageStore_u1(o_img, out_col_pos + uvec2(0,2), t0.z);\n"
  "imageStore_u1(o_img, out_col_pos + uvec2(0,3), t0.w);\n"
  "imageStore_u1(o_img, out_col_pos + uvec2(0,4), t1.x);\n"
  "imageStore_u1(o_img, out_col_pos + uvec2(0,5), t1.y);\n"
  "imageStore_u1(o_img, out_col_pos + uvec2(0,6), t1.z);\n"
  "imageStore_u1(o_img, out_col_pos + uvec2(0,7), t1.w);\n"
  "#endif\n"
  "}\n"
  "#endif\n"
  "LOCALFUNC void run_IDCTs(uint flat_id, uint ptr, uint invoc, uvec2 work_group_id METAL_ARGD)\n"
  "{\n"
  "ptr = decode_flags(ptr, invoc METAL_ARGS);\n"
  "group_sync();\n"
  "uint lane_mask = 1u << (invoc & 31);\n"
  "uint prev_mask = lane_mask - 1;\n"
  "for (uint block_base = 0; block_base < BLOCKS_PER_MB; block_base += 8)\n"
  "{\n"
  "for (uint i = 0; i < 64*8; i += 64)\n"
  "coeffs[invoc + i] = 0;\n"
  "group_sync();\n"
  "#ifdef SUB_PLANE\n"
  "for (uint block = 0; block < 4; block++)\n"
  "{\n"
  "uint i = invoc & 31;\n"
  "uint block_idx = block + ((invoc & 32) >> 3);\n"
  "uvec2 nonzero = ac_nonzero[block_idx];\n"
  "if ((nonzero.x & lane_mask) != 0)\n"
  "coeffs[block_idx + bufferFetch(zigzag8, i).x] = get_int16(ptr + bitCount(nonzero.x & prev_mask) METAL_ARGS);\n"
  "ptr += bitCount(nonzero.x);\n"
  "if ((nonzero.y & lane_mask) != 0)\n"
  "coeffs[block_idx + bufferFetch(zigzag8, i+32).x] = get_int16(ptr + bitCount(nonzero.y & prev_mask) METAL_ARGS);\n"
  "ptr += bitCount(nonzero.y);\n"
  "}\n"
  "#else\n"
  "for (uint block = 0; block < 8; block++)\n"
  "{\n"
  "uvec2 nonzero = ac_nonzero[block_base + block];\n"
  "uint fetch_offs = ptr;\n"
  "uint which = nonzero.x;\n"
  "if (invoc >= 32)\n"
  "{\n"
  "fetch_offs += bitCount(nonzero.x);\n"
  "which = nonzero.y;\n"
  "}\n"
  "if ((which & lane_mask) != 0)\n"
  "coeffs[block + bufferFetch(zigzag8, invoc).x] = get_int16(fetch_offs + bitCount(which & prev_mask) METAL_ARGS);\n"
  "ptr += bitCount(nonzero.x) + bitCount(nonzero.y);\n"
  "}\n"
  "#endif\n"
  "group_sync();\n"
  "if (invoc < 8)\n"
  "{\n"
  "#ifdef SUB_PLANE\n"
  "uint dc_index = (flat_id * BLOCKS_PER_MB) + (invoc & 3) + (invoc >= BLOCKS_PER_MB ? U0(cb_offs_dc) : 0);\n"
  "uint dc_offs = (invoc & 1) + ((invoc & 2) << 1) + ((invoc & 4) >> 1);\n"
  "#else\n"
  "uint dc_index = (flat_id * BLOCKS_PER_MB) + block_base + invoc;\n"
  "uint dc_offs = block_base + (invoc & 1) + ((invoc & 2) << 1) + ((invoc & 4) >> 1);\n"
  "#endif\n"
  "#ifndef MOTION\n"
  "dc_offs = invoc;\n"
  "#endif\n"
  "int dcflags = get_dc(dc_index METAL_ARGS);\n"
  "coeffs[invoc] = bitfieldExtract(dcflags, 0, 13) * 8 + 32;\n"
  "dcf_linear[dc_offs] = uint(dcflags);\n"
  "}\n"
  "group_sync();\n"
  "uint rel_block_id = (invoc >> 0) & 7;\n"
  "uint row_col_id = (invoc >> 3) & 7;\n"
  "ivec4 t0, t1;\n"
  "idct_2d(t0, t1, rel_block_id, row_col_id, block_base + rel_block_id, work_group_id METAL_ARGS);\n"
  "store_residual_col(row_col_id, block_base + rel_block_id, t0, t1, invoc, work_group_id METAL_ARGS);\n"
  "}\n"
  "}\n"
  "#ifdef MOTION\n"
  "SHARED_GLOBAL(ivec2, motion_vecs[4]);\n"
  "LOCALFUNC int clamp_motion_old(int x, ivec4 clampv)\n"
  "{\n"
  "bool half_pel = (x & 1) != 0;\n"
  "uint tl = uint(half_pel ? clampv.z : clampv.x);\n"
  "uint wh = uint(half_pel ? clampv.w : clampv.y);\n"
  "return (uint(x) - tl <= wh) ? x : int((uint(x) < tl) ? tl : wh);\n"
  "}\n"
  "LOCALFUNC int clamp_motion_new(int x, ivec4 clampv)\n"
  "{\n"
  "bool half_pel = (x & 1) != 0;\n"
  "return clamp(x, half_pel ? clampv.z : clampv.x, half_pel ? clampv.w : clampv.y);\n"
  "}\n"
  "LOCALFUNC void fetch_motion(uint block_id, uint invoc, uvec2 work_group_id METAL_ARGD)\n"
  "{\n"
  "if (invoc >= 4)\n"
  "return;\n"
  "uint flat_id = block_id * 4 + invoc;\n"
  "ivec2 rel_vec = ivec2(bufferFetch(motion_buf, flat_id).xy);\n"
  "ivec2 base_pos = ivec2(work_group_id.xy) * 64 + ivec2((invoc & 1) << 5, (invoc & 2) << 4);\n"
  "ivec2 abs_vec = base_pos + rel_vec;\n"
  "if ((U0(frame_flags) & BINKGPUNEWCLAMP) != 0)\n"
  "{\n"
  "abs_vec.x = clamp_motion_new(abs_vec.x, U0(mv_x_clamp));\n"
  "abs_vec.y = clamp_motion_new(abs_vec.y, U0(mv_y_clamp));\n"
  "}\n"
  "else\n"
  "{\n"
  "abs_vec.x = clamp_motion_old(abs_vec.x, U0(mv_x_clamp));\n"
  "abs_vec.y = clamp_motion_old(abs_vec.y, U0(mv_y_clamp));\n"
  "}\n"
  "motion_vecs[invoc] = abs_vec;\n"
  "}\n"
  "#ifndef SUB_PLANE\n"
  "LOCALFUNC int halfpel(int NA, int NB, int NC, int PC, int PB, int PA)\n"
  "{\n"
  "int A = (NA + PA + 16) & ~1;\n"
  "int B = (NB + PB) << 2;\n"
  "int C = NC + PC;\n"
  "return (A + imul24(C, 19) - B) >> 5;\n"
  "}\n"
  "LOCALFUNC int pack(int x, int y)\n"
  "{\n"
  "return (x & 0xfff) | ((y & 0xfff) << 16);\n"
  "}\n"
  "LOCALFUNC ivec2 dual_halfpel(int NA, int NB, int NC, int PC, int PB, int PA)\n"
  "{\n"
  "int A = (NA + PA + 0x00100010) & ~0x00010001;\n"
  "int B = (NB + PB) << 2;\n"
  "int C = NC + PC;\n"
  "int Ax = bitfieldExtract(A, 0, 12), Ay = bitfieldExtract(A, 16, 12);\n"
  "int Bx = bitfieldExtract(B, 0, 14), By = bitfieldExtract(B, 16, 14);\n"
  "int Cx = bitfieldExtract(C, 0, 12), Cy = bitfieldExtract(C, 16, 12);\n"
  "int Sx = (Ax + imul24(Cx, 19) - Bx) >> 5;\n"
  "int Sy = (Ay + imul24(Cy, 19) - By) >> 5;\n"
  "return ivec2(Sx, Sy);\n"
  "}\n"
  "LOCALFUNC ivec4 gather_halfpel_4x(vec2 st, ivec2 offs_step METAL_ARGD)\n"
  "{\n"
  "ivec2 offs = ivec2(0, 0);\n"
  "ivec4 NA = ivec4(textureGatherOffset(i_img, st, offs)); offs += offs_step;\n"
  "ivec4 NB = ivec4(textureGatherOffset(i_img, st, offs)); offs += offs_step;\n"
  "ivec4 NC = ivec4(textureGatherOffset(i_img, st, offs)); offs += offs_step;\n"
  "ivec4 PC = ivec4(textureGatherOffset(i_img, st, offs)); offs += offs_step;\n"
  "ivec4 PB = ivec4(textureGatherOffset(i_img, st, offs)); offs += offs_step;\n"
  "ivec4 PA = ivec4(textureGatherOffset(i_img, st, offs));\n"
  "ivec4 o;\n"
  "o.x = halfpel(NA.x, NB.x, NC.x, PC.x, PB.x, PA.x);\n"
  "o.y = halfpel(NA.y, NB.y, NC.y, PC.y, PB.y, PA.y);\n"
  "o.z = halfpel(NA.z, NB.z, NC.z, PC.z, PB.z, PA.z);\n"
  "o.w = halfpel(NA.w, NB.w, NC.w, PC.w, PB.w, PA.w);\n"
  "return o;\n"
  "}\n"
  "LOCALFUNC void store_2x2(uvec2 pos, uint residual_offs, ivec4 values METAL_ARGD)\n"
  "{\n"
  "values = clamp(values, 0, 255);\n"
  "ivec2 res_l = unpack_res(residual[residual_offs + 0]);\n"
  "ivec2 res_r = unpack_res(residual[residual_offs + 1]);\n"
  "values = clamp(values + ivec4(res_l.x, res_r.x, res_l.y, res_r.y), 0, 255);\n"
  "int avg0 = (values.x + values.z + 1) >> 1;\n"
  "int avg1 = (values.y + values.w + 1) >> 1;\n"
  "residual[residual_offs] = (avg1 << 16) | avg0;\n"
  "imageStore_u1(o_img, pos + uvec2(0,0), values.x);\n"
  "imageStore_u1(o_img, pos + uvec2(1,0), values.y);\n"
  "imageStore_u1(o_img, pos + uvec2(0,1), values.z);\n"
  "imageStore_u1(o_img, pos + uvec2(1,1), values.w);\n"
  "}\n"
  "LOCALFUNC void full_motion_16x16(uint id16x16, uint invoc, uvec2 work_group_id METAL_ARGD)\n"
  "{\n"
  "ivec2 lane_xy = ivec2(invoc & 7, invoc >> 3) << 1;\n"
  "ivec2 motion_vec = motion_vecs[id16x16];\n"
  "uint motion_type = uint((motion_vec.x & 1) | ((motion_vec.y & 1) << 1));\n"
  "ivec2 fetch_pos = lane_xy + (motion_vec >> 1) - ((motion_vec & 1) << 1);\n"
  "vec2 st = vec2(fetch_pos) * U0(luma_tex_scale_offs).xy + U0(luma_tex_scale_offs).zw;\n"
  "ivec4 out_pix;\n"
  "if (motion_type == 0)\n"
  "out_pix = ivec4(textureGather(i_img, st)).wzxy;\n"
  "#ifdef AVOID_VARIABLE_OFFS\n"
  "else if (motion_type == 1)\n"
  "out_pix = gather_halfpel_4x(st, ivec2(1, 0) METAL_ARGS).wzxy;\n"
  "else if (motion_type == 2)\n"
  "out_pix = gather_halfpel_4x(st, ivec2(0, 1) METAL_ARGS).wzxy;\n"
  "#else\n"
  "else if (motion_type != 3)\n"
  "{\n"
  "ivec2 dir = (motion_type == 1) ? ivec2(1, 0) : ivec2(0, 1);\n"
  "out_pix = gather_halfpel_4x(st, dir METAL_ARGS).wzxy;\n"
  "}\n"
  "#endif\n"
  "else\n"
  "{\n"
  "#define PASS_STRIDE 8\n"
  "#define pass_buffer coeffs\n"
  "ivec4 top = gather_halfpel_4x(st, ivec2(1, 0) METAL_ARGS);\n"
  "pass_buffer[invoc +  0*PASS_STRIDE] = pack(top.w, top.z);\n"
  "pass_buffer[invoc + 11*PASS_STRIDE] = pack(top.x, top.y);\n"
  "if (lane_xy.y < 6)\n"
  "{\n"
  "vec2 st_bottom = vec2(fetch_pos.x, fetch_pos.y + 16) * U0(luma_tex_scale_offs).xy + U0(luma_tex_scale_offs).zw;\n"
  "ivec4 bot = gather_halfpel_4x(st_bottom, ivec2(1, 0) METAL_ARGS);\n"
  "pass_buffer[invoc +  8*PASS_STRIDE] = pack(bot.w, bot.z);\n"
  "pass_buffer[invoc + 19*PASS_STRIDE] = pack(bot.x, bot.y);\n"
  "}\n"
  "group_sync();\n"
  "int row0 = pass_buffer[invoc +  0*PASS_STRIDE];\n"
  "int row1 = pass_buffer[invoc + 11*PASS_STRIDE];\n"
  "int row2 = pass_buffer[invoc +  1*PASS_STRIDE];\n"
  "int row3 = pass_buffer[invoc + 12*PASS_STRIDE];\n"
  "int row4 = pass_buffer[invoc +  2*PASS_STRIDE];\n"
  "int row5 = pass_buffer[invoc + 13*PASS_STRIDE];\n"
  "int row6 = pass_buffer[invoc +  3*PASS_STRIDE];\n"
  "out_pix.xy = dual_halfpel(row0, row1, row2, row3, row4, row5);\n"
  "out_pix.zw = dual_halfpel(row1, row2, row3, row4, row5, row6);\n"
  "}\n"
  "uvec2 block_xy = uvec2((id16x16 & 1) << 4, (id16x16 & 2) << 3) + uvec2(lane_xy.x, lane_xy.y);\n"
  "uvec2 out_pos = work_group_id.xy * MB_EDGE_LEN + block_xy;\n"
  "uint residual_offs = RESIDUAL_OFFS(block_xy.x, block_xy.y >> 1);\n"
  "store_2x2(out_pos, residual_offs, out_pix METAL_ARGS);\n"
  "}\n"
  "#else\n"
  "LOCALFUNC uint packed_fetch(ivec2 pos METAL_ARGD)\n"
  "{\n"
  "uvec2 v = texelFetch(i_img, pos, 0).xy;\n"
  "return bitfieldInsert(v.x, v.y, 16, 16);\n"
  "}\n"
  "LOCALFUNC ivec2 bilerp4(uint t00, uint t01, uint t10, uint t11, uvec2 motion_vec)\n"
  "{\n"
  "uint x0 = ((t00 << 2) + uint(motion_vec.x & 3) * (t10 - t00)) & 0x03ff03ff;\n"
  "uint x1 = ((t01 << 2) + uint(motion_vec.x & 3) * (t11 - t01)) & 0x03ff03ff;\n"
  "uint r  = ( (x0 << 2) + uint(motion_vec.y & 3) * ( x1 -  x0) + 0x00080008);\n"
  "return ivec2(bitfieldExtract(r, 4, 8), bitfieldExtract(r, 20, 8));\n"
  "}\n"
  "LOCALFUNC ivec4 residual_crcb(uint offs METAL_ARGD)\n"
  "{\n"
  "return ivec4(unpack_res(residual[offs]), unpack_res(residual[offs + RESIDUAL_OFFS(16,0)]));\n"
  "}\n"
  "LOCALFUNC void sub_motion_16x16(uint invoc, uvec2 work_group_id METAL_ARGD)\n"
  "{\n"
  "uvec2 lane_xy = uvec2(invoc & 7, invoc >> 3) << 1;\n"
  "uvec2 motion_vec = uvec2(motion_vecs[(lane_xy.x >> 3) + ((lane_xy.y & 8) >> 2)]);\n"
  "ivec2 fetch_pos = ivec2(lane_xy & 7) + ivec2(motion_vec >> 2);\n"
  "uint tex00 = packed_fetch(fetch_pos + ivec2(0, 0) METAL_ARGS);\n"
  "uint tex01 = packed_fetch(fetch_pos + ivec2(0, 1) METAL_ARGS);\n"
  "uint tex02 = packed_fetch(fetch_pos + ivec2(0, 2) METAL_ARGS);\n"
  "uint tex10 = packed_fetch(fetch_pos + ivec2(1, 0) METAL_ARGS);\n"
  "uint tex11 = packed_fetch(fetch_pos + ivec2(1, 1) METAL_ARGS);\n"
  "uint tex12 = packed_fetch(fetch_pos + ivec2(1, 2) METAL_ARGS);\n"
  "uint tex20 = packed_fetch(fetch_pos + ivec2(2, 0) METAL_ARGS);\n"
  "uint tex21 = packed_fetch(fetch_pos + ivec2(2, 1) METAL_ARGS);\n"
  "uint tex22 = packed_fetch(fetch_pos + ivec2(2, 2) METAL_ARGS);\n"
  "ivec2 interp00 = bilerp4(tex00, tex01, tex10, tex11, motion_vec);\n"
  "ivec2 interp01 = bilerp4(tex01, tex02, tex11, tex12, motion_vec);\n"
  "ivec2 interp10 = bilerp4(tex10, tex11, tex20, tex21, motion_vec);\n"
  "ivec2 interp11 = bilerp4(tex11, tex12, tex21, tex22, motion_vec);\n"
  "uint residual_offs = RESIDUAL_OFFS(lane_xy.x, lane_xy.y >> 1);\n"
  "ivec4 res_l = residual_crcb(residual_offs + RESIDUAL_OFFS( 0,0) METAL_ARGS);\n"
  "ivec4 res_r = residual_crcb(residual_offs + RESIDUAL_OFFS( 1,0) METAL_ARGS);\n"
  "ivec2 final00 = clamp(interp00 + res_l.xz, 0, 255);\n"
  "ivec2 final01 = clamp(interp01 + res_l.yw, 0, 255);\n"
  "ivec2 final10 = clamp(interp10 + res_r.xz, 0, 255);\n"
  "ivec2 final11 = clamp(interp11 + res_r.yw, 0, 255);\n"
  "residual[residual_offs + RESIDUAL_OFFS( 0, 0)] = (final00.x + final01.x + 1) >> 1;\n"
  "residual[residual_offs + RESIDUAL_OFFS(16, 0)] = (final00.y + final01.y + 1) >> 1;\n"
  "residual[residual_offs + RESIDUAL_OFFS( 1, 0)] = (final10.x + final11.x + 1) >> 1;\n"
  "residual[residual_offs + RESIDUAL_OFFS(17, 0)] = (final10.y + final11.y + 1) >> 1;\n"
  "uvec2 out_pos = work_group_id.xy * MB_EDGE_LEN + lane_xy;\n"
  "imageStore_u2(o_img, out_pos + uvec2(0,0), final00);\n"
  "imageStore_u2(o_img, out_pos + uvec2(0,1), final01);\n"
  "imageStore_u2(o_img, out_pos + uvec2(1,0), final10);\n"
  "imageStore_u2(o_img, out_pos + uvec2(1,1), final11);\n"
  "}\n"
  "#endif\n"
  "LOCALFUNC void deblock_kernel(INOUT_PARA(ivec4, pixels), uint dc0, uint dc1)\n"
  "{\n"
  "int diff = pixels.z - pixels.y;\n"
  "int delta_near = (diff + 2) >> 2;\n"
  "int delta_far = (diff + 4) >> 3;\n"
  "pixels.x += (dc0 >= (2 << 13)) ? delta_far  : 0;\n"
  "pixels.y += (dc0 >= (1 << 13)) ? delta_near : 0;\n"
  "pixels.z -= (dc1 >= (1 << 13)) ? delta_near : 0;\n"
  "pixels.w -= (dc1 >= (2 << 13)) ? delta_far  : 0;\n"
  "}\n"
  "LOCALFUNC bool should_deblock(uint dc0, uint dc1)\n"
  "{\n"
  "dc0 &= 0x6fff;\n"
  "dc1 &= 0x6fff;\n"
  "return (dc0 | dc1) >= (1 << 13) &&\n"
  "((dc0 & dc1) < (3 << 13) || (dc0 ^ 0x800) - (dc1 ^ 0x800) + 32 >= 65);\n"
  "}\n"
  "LOCALFUNC void deblock_UandD(uint offs, uint dc0, uint dc1 METAL_ARGD)\n"
  "{\n"
  "ivec4 p0, p1;\n"
  "ivec2 t;\n"
  "t = unpack_res(residual[offs + 0]); p0.x = t.x; p1.x = t.y;\n"
  "t = unpack_res(residual[offs + 1]); p0.y = t.x; p1.y = t.y;\n"
  "t = unpack_res(residual[offs + 2]); p0.z = t.x; p1.z = t.y;\n"
  "t = unpack_res(residual[offs + 3]); p0.w = t.x; p1.w = t.y;\n"
  "deblock_kernel(p0, dc0, dc1);\n"
  "deblock_kernel(p1, dc0, dc1);\n"
  "residual[offs + 0] = pack_res(ivec2(p0.x, p1.x));\n"
  "residual[offs + 1] = pack_res(ivec2(p0.y, p1.y));\n"
  "residual[offs + 2] = pack_res(ivec2(p0.z, p1.z));\n"
  "residual[offs + 3] = pack_res(ivec2(p0.w, p1.w));\n"
  "}\n"
  "LOCALFUNC void deblock_LtoR(uint offs, uint dc0, uint dc1 METAL_ARGD)\n"
  "{\n"
  "ivec4 p0, p1;\n"
  "p0.xy = unpack_res(residual[offs + RESIDUAL_OFFS(0, 0)]);\n"
  "p0.zw = unpack_res(residual[offs + RESIDUAL_OFFS(0, 1)]);\n"
  "p1.xy = unpack_res(residual[offs + RESIDUAL_OFFS(1, 0)]);\n"
  "p1.zw = unpack_res(residual[offs + RESIDUAL_OFFS(1, 1)]);\n"
  "deblock_kernel(p0, dc0, dc1);\n"
  "deblock_kernel(p1, dc0, dc1);\n"
  "residual[offs + RESIDUAL_OFFS(0, 0)] = pack_res(p0.xy);\n"
  "residual[offs + RESIDUAL_OFFS(0, 1)] = pack_res(p0.zw);\n"
  "residual[offs + RESIDUAL_OFFS(1, 0)] = pack_res(p1.xy);\n"
  "residual[offs + RESIDUAL_OFFS(1, 1)] = pack_res(p1.zw);\n"
  "}\n"
  "LOCALFUNC void deblock_residuals(uint invoc METAL_ARGD)\n"
  "{\n"
  "#ifdef SUB_PLANE\n"
  "if ((U0(frame_flags) & (BINKGPUDEBLOCKUD|BINKGPUBINK24)) == BINKGPUDEBLOCKUD && invoc < 16)\n"
  "{\n"
  "uint plane_id = invoc >> 3;\n"
  "uint dc_base = (invoc & 4) + plane_id * 2;\n"
  "uint dc0 = dcf_linear[dc_base+0];\n"
  "uint dc1 = dcf_linear[dc_base+1];\n"
  "if (should_deblock(dc0, dc1))\n"
  "deblock_UandD(RESIDUAL_OFFS(6 + plane_id*16, invoc & 7), dc0, dc1 METAL_ARGS);\n"
  "}\n"
  "group_sync();\n"
  "if ((U0(frame_flags) & (BINKGPUDEBLOCKLR|BINKGPUBINK24)) == BINKGPUDEBLOCKLR && invoc < 16)\n"
  "{\n"
  "uint dc_base = invoc >> 2;\n"
  "uint dc0 = dcf_linear[dc_base+0];\n"
  "uint dc1 = dcf_linear[dc_base+4];\n"
  "if (should_deblock(dc0, dc1))\n"
  "deblock_LtoR(RESIDUAL_OFFS(invoc * 2, 3), dc0, dc1 METAL_ARGS);\n"
  "}\n"
  "#else\n"
  "if ((U0(frame_flags) & (BINKGPUDEBLOCKUD|BINKGPUBINK24)) == BINKGPUDEBLOCKUD && invoc < 48)\n"
  "{\n"
  "uint x_offs = invoc >> 4;\n"
  "uint dc_base = (invoc & 0xc) + x_offs;\n"
  "uint dc0 = dcf_linear[dc_base+0];\n"
  "uint dc1 = dcf_linear[dc_base+1];\n"
  "if (should_deblock(dc0, dc1))\n"
  "deblock_UandD(RESIDUAL_OFFS(6 + x_offs*8, invoc & 15), dc0, dc1 METAL_ARGS);\n"
  "}\n"
  "group_sync();\n"
  "if ((U0(frame_flags) & (BINKGPUDEBLOCKLR|BINKGPUBINK24)) == BINKGPUDEBLOCKLR && invoc < 48)\n"
  "{\n"
  "uint y_offs = invoc >> 4;\n"
  "uint dc_base = ((invoc & 0xc) >> 2) + y_offs*4;\n"
  "uint dc0 = dcf_linear[dc_base+0];\n"
  "uint dc1 = dcf_linear[dc_base+4];\n"
  "if (should_deblock(dc0, dc1))\n"
  "deblock_LtoR(RESIDUAL_OFFS((invoc & 15) * 2, 3 + y_offs*4), dc0, dc1 METAL_ARGS);\n"
  "}\n"
  "#endif\n"
  "}\n"
  "LOCALFUNC void calc_averages(uint flat_id, uint invoc METAL_ARGD)\n"
  "{\n"
  "#ifdef SUB_PLANE\n"
  "uint block_id = (invoc >> 3) & 7;\n"
  "uint block_offs = RESIDUAL_OFFS((block_id & 3) * 8, (block_id >> 2) * 4);\n"
  "uint col_offs = block_offs + RESIDUAL_OFFS(invoc & 7, 0);\n"
  "#else\n"
  "uint block_id = invoc >> 2;\n"
  "uint block_offs = RESIDUAL_OFFS((block_id & 3) * 8, (block_id >> 2) * 4);\n"
  "uint col_offs = block_offs + RESIDUAL_OFFS((invoc & 3) * 2, 0);\n"
  "#endif\n"
  "int avg01 = residual[col_offs + RESIDUAL_OFFS(0,0)];\n"
  "int avg23 = residual[col_offs + RESIDUAL_OFFS(0,1)];\n"
  "int avg45 = residual[col_offs + RESIDUAL_OFFS(0,2)];\n"
  "int avg67 = residual[col_offs + RESIDUAL_OFFS(0,3)];\n"
  "int avg03 = (avg01 + avg23 + 0x00010001) & 0x01fe01fe;\n"
  "int avg47 = (avg45 + avg67 + 0x00010001) & 0x01fe01fe;\n"
  "int avg07 = ((avg03 + avg47 + 0x00020002) >> 2);\n"
  "#ifdef SEPARATE_DCF_ATOMIC\n"
  "atomicStore(dcf_atomic[block_id], dcf_linear[block_id] & 0xe000);\n"
  "#else\n"
  "atomicAnd(dcf_atomic[block_id], 0xe000);\n"
  "#endif\n"
  "group_sync();\n"
  "#ifdef SUB_PLANE\n"
  "atomicAdd(dcf_atomic[block_id], uint(avg07 & 0xff));\n"
  "group_sync();\n"
  "if (invoc < 8)\n"
  "{\n"
  "uint out_offs = (flat_id*4 + (((invoc & 2) != 0) ? U0(cb_offs_dc) : 0) + (invoc & 1) + ((invoc >> 1) & 2));\n"
  "imageStore_buf_i1s(dc_out_buf, DC_WRITE_OFFS + out_offs, bitfieldExtract(int(atomicLoad(dcf_atomic[invoc])), 0, 16));\n"
  "}\n"
  "#else\n"
  "uint colsum = uint((avg07 & 0xff) + (avg07 >> 16));\n"
  "atomicAdd(dcf_atomic[block_id], colsum);\n"
  "group_sync();\n"
  "if (invoc < 16)\n"
  "{\n"
  "uint out_offs = (flat_id * 16) + (invoc & 9) + ((invoc << 1) & 4) + ((invoc >> 1) & 2);\n"
  "imageStore_buf_i1s(dc_out_buf, DC_WRITE_OFFS + out_offs, bitfieldExtract(int(atomicLoad(dcf_atomic[invoc])), 0, 16));\n"
  "}\n"
  "#endif\n"
  "}\n"
  "LOCALFUNC void copy_dcs(uint flat_id, uint invoc METAL_ARGD)\n"
  "{\n"
  "#ifdef SUB_PLANE\n"
  "if (invoc < 2 * BLOCKS_PER_MB)\n"
  "{\n"
  "uint offs = flat_id*BLOCKS_PER_MB + (invoc & (BLOCKS_PER_MB - 1)) + (invoc >= BLOCKS_PER_MB ? U0(cb_offs_dc) : 0);\n"
  "imageStore_buf_i1s(dc_out_buf, DC_WRITE_OFFS + offs, get_dc(offs METAL_ARGS));\n"
  "}\n"
  "#else\n"
  "if (invoc < BLOCKS_PER_MB)\n"
  "{\n"
  "uint offs = flat_id*BLOCKS_PER_MB + invoc;\n"
  "imageStore_buf_i1s(dc_out_buf, DC_WRITE_OFFS + offs, get_dc(offs METAL_ARGS));\n"
  "}\n"
  "#endif\n"
  "}\n"
  "LOCALFUNC void clear_residuals(uint invoc METAL_ARGD)\n"
  "{\n"
  "#ifndef METAL_LANG\n"
  "for (uint offs = 0; offs < RESIDUAL_W*RESIDUAL_H/2; offs += 64)\n"
  "residual[offs + invoc] = 0;\n"
  "#else\n"
  "for (uint offs = 0; offs < RESIDUAL_W*RESIDUAL_H/2; offs += 64*4)\n"
  "*((threadgroup uvec4 *) &residual[offs + invoc*4]) = 0;\n"
  "#endif\n"
  "}\n"
  "LOCALFUNC void main_motion(uint flat_id, uint invoc, uvec2 work_group_id METAL_ARGD)\n"
  "{\n"
  "fetch_motion(flat_id, invoc, work_group_id METAL_ARGS);\n"
  "uint ptr;\n"
  "if (fetch_residual_ptr(ptr, flat_id, invoc METAL_ARGS))\n"
  "{\n"
  "run_IDCTs(flat_id, ptr, invoc, work_group_id METAL_ARGS);\n"
  "group_sync();\n"
  "deblock_residuals(invoc METAL_ARGS);\n"
  "}\n"
  "else\n"
  "{\n"
  "if (invoc < BLOCKS_TOTAL)\n"
  "dcf_linear[invoc] = 0;\n"
  "clear_residuals(invoc METAL_ARGS);\n"
  "}\n"
  "group_sync();\n"
  "#ifdef SUB_PLANE\n"
  "sub_motion_16x16(invoc, work_group_id METAL_ARGS);\n"
  "#else\n"
  "for (uint block = 0; block < 4; block++)\n"
  "full_motion_16x16(block, invoc, work_group_id METAL_ARGS);\n"
  "#endif\n"
  "uint dc_offs = flat_id*BLOCKS_PER_MB;\n"
  "uint right_delta = (work_group_id.x + 1 >= U0(size_in_blocks).x) ? 0 : BLOCKS_PER_MB;\n"
  "uint bottom_offs = (work_group_id.y + 1 >= U0(size_in_blocks).y) ? dc_offs : (flat_id + U0(size_in_blocks).x) * BLOCKS_PER_MB;\n"
  "int adjacent_mode = get_dc(dc_offs + right_delta METAL_ARGS) | get_dc(bottom_offs METAL_ARGS) | get_dc(bottom_offs + right_delta METAL_ARGS);\n"
  "if (adjacent_mode < 0)\n"
  "{\n"
  "group_sync();\n"
  "calc_averages(flat_id, invoc METAL_ARGS);\n"
  "}\n"
  "#ifdef NEED_DC_COPY\n"
  "else\n"
  "copy_dcs(flat_id, invoc METAL_ARGS);\n"
  "#endif\n"
  "}\n"
  "#else\n"
  "LOCALFUNC void main_dct(uint flat_id, uint invoc, uvec2 work_group_id METAL_ARGD)\n"
  "{\n"
  "uint ptr;\n"
  "fetch_residual_ptr(ptr, flat_id, invoc METAL_ARGS);\n"
  "run_IDCTs(flat_id, ptr, invoc, work_group_id METAL_ARGS);\n"
  "}\n"
  "#endif\n"
  "#ifdef MOTION\n"
  "ROOT_SIGNATURE(RootSigMDCT)\n"
  "#else\n"
  "ROOT_SIGNATURE(RootSigDCT)\n"
  "#endif\n"
  "COMPUTE_SHADER_MAIN(64, 1, 1)\n"
  "#ifdef METAL_LANG\n"
  ",\n"
  "constant frame_consts& u0 [[ buffer(0) ]],\n"
  "device short1 *zigzag8 [[ buffer(1) ]],\n"
  "device int1 *coeff_data [[ buffer(2) ]],\n"
  "device short1 *dc_data [[ buffer(3) ]],\n"
  "device short2 *motion_buf [[ buffer(4) ]],\n"
  "device short1 *dc_out_buf [[ buffer(5) ]],\n"
  "rwtexture2d_ushort o_img [[ texture(0) ]],\n"
  "texture2d<METAL_INTEXTYPE> i_img [[ texture(1) ]]\n"
  ")\n"
  "#endif\n"
  "{\n"
  "#ifdef METAL_LANG\n"
  "threadgroup uvec2 ac_nonzero[BLOCKS_TOTAL];\n"
  "threadgroup int coeffs[64*8];\n"
  "threadgroup uint dcf_linear[BLOCKS_TOTAL];\n"
  "threadgroup atomic_uint dcf_atomic[BLOCKS_TOTAL];\n"
  "threadgroup ivec2 motion_vecs[4];\n"
  "threadgroup int residual[RESIDUAL_W*RESIDUAL_H/2];\n"
  "#endif\n"
  "uint invoc = gl_LocalInvocationID.x;\n"
  "uvec2 work_group_id = gl_WorkGroupID.xy;\n"
  "uint flat_id = work_group_id.y*U0(size_in_blocks).x + work_group_id.x;\n"
  "int dc_mode = get_dc(flat_id * BLOCKS_PER_MB METAL_ARGS);\n"
  "#ifdef MOTION\n"
  "if (dc_mode >= 0)\n"
  "main_motion(flat_id, invoc, work_group_id METAL_ARGS);\n"
  "#ifdef NEED_DC_COPY\n"
  "else\n"
  "copy_dcs(flat_id, invoc METAL_ARGS);\n"
  "#endif\n"
  "#else\n"
  "if (dc_mode < 0)\n"
  "main_dct(flat_id, invoc, work_group_id METAL_ARGS);\n"
  "#endif\n"
  "}\n";
static char const shader_source_frag5[] =
  "#define MOTION\n";
static char const shader_source_frag6[] =
  "#define SUB_PLANE\n";

#define NUMFRAGMENTS_cshader_bink2block 6
static char const * const cshader_bink2block[4][NUMFRAGMENTS_cshader_bink2block] = {
   { shader_source_frag0, shader_source_frag1, shader_source_frag1, shader_source_frag2, shader_source_frag3, shader_source_frag4, },
   { shader_source_frag0, shader_source_frag1, shader_source_frag5, shader_source_frag2, shader_source_frag3, shader_source_frag4, },
   { shader_source_frag0, shader_source_frag6, shader_source_frag1, shader_source_frag2, shader_source_frag3, shader_source_frag4, },
   { shader_source_frag0, shader_source_frag6, shader_source_frag5, shader_source_frag2, shader_source_frag3, shader_source_frag4, },
};

static char const shader_source_frag7[] =
  "#ifdef DC_PREDICT_NO_LOOP\n"
  "#define NUM_INVOCATIONS MAX_WIDTH32\n"
  "#else\n"
  "#define NUM_INVOCATIONS 64\n"
  "#endif\n"
  "#ifdef DC_TYPELESS\n"
  "DECLARE_IMAGE_TYPELESS_BUF(0, all_dc_buf);\n"
  "#define full_dc_buf all_dc_buf\n"
  "#define sub_dc_buf all_dc_buf\n"
  "#else\n"
  "DECLARE_IMAGE_RGBA32I_BUF(0, full_dc_buf);\n"
  "DECLARE_IMAGE_RG32I_BUF(1, sub_dc_buf);\n"
  "#endif\n"
  "#define METAL_ARGD \\\n"
  "METAL_ARG(device ivec4 *full_dc_buf) METAL_ARG(device ivec2 *sub_dc_buf)\n"
  "#define METAL_ARGS \\\n"
  "METAL_ARG(full_dc_buf) METAL_ARG(sub_dc_buf)\n"
  "SHARED_GLOBAL(ivec4, edge_dcs[MAX_WIDTH32]);\n"
  "LOCALFUNC void unpack_dcs(OUT_PARA(int, a), OUT_PARA(int, b), int p)\n"
  "{\n"
  "a = bitfieldExtract(p, 0, 13);\n"
  "b = bitfieldExtract(p, 16, 13);\n"
  "}\n"
  "LOCALFUNC bool read_full_dcs(OUT_PARA(int, dc0), OUT_PARA(int, dc1), OUT_PARA(int, dc2), OUT_PARA(int, dc3),\n"
  "OUT_PARA(int, dc4), OUT_PARA(int, dc5), OUT_PARA(int, dc6), OUT_PARA(int, dc7),\n"
  "OUT_PARA(ivec4, v), uint group, uint block_base METAL_ARGD)\n"
  "{\n"
  "v = imageLoad_buf_i4(full_dc_buf, block_base + group);\n"
  "unpack_dcs(dc0, dc1, v.x);\n"
  "unpack_dcs(dc2, dc3, v.y);\n"
  "unpack_dcs(dc4, dc5, v.z);\n"
  "unpack_dcs(dc6, dc7, v.w);\n"
  "return v.x < 0;\n"
  "}\n"
  "LOCALFUNC void write_full_dcs(int dc0, int dc1, int dc2, int dc3,\n"
  "int dc4, int dc5, int dc6, int dc7,\n"
  "ivec4 v, uint group, uint block_base METAL_ARGD)\n"
  "{\n"
  "ivec4 p = ivec4(pack16(dc0, dc1), pack16(dc2, dc3), pack16(dc4, dc5), pack16(dc6, dc7));\n"
  "imageStore_buf_i4(full_dc_buf, block_base + group, ivec4(bitSelect(0xe000e000, v, p)));\n"
  "}\n"
  "LOCALFUNC bool read_sub_dcs(OUT_PARA(int, dc0), OUT_PARA(int, dc1), OUT_PARA(int, dc2), OUT_PARA(int, dc3), OUT_PARA(ivec2, v), uint block_offs METAL_ARGD)\n"
  "{\n"
  "v = imageLoad_buf_i2(sub_dc_buf, block_offs).xy;\n"
  "unpack_dcs(dc0, dc1, v.x);\n"
  "unpack_dcs(dc2, dc3, v.y);\n"
  "return v.x < 0;\n"
  "}\n"
  "LOCALFUNC void write_sub_dcs(int dc0, int dc1, int dc2, int dc3, ivec2 v, uint block_offs METAL_ARGD)\n"
  "{\n"
  "ivec2 p = ivec2(pack16(dc0, dc1), pack16(dc2, dc3));\n"
  "imageStore_buf_i2(sub_dc_buf, block_offs, ivec2(bitSelect(0xe000e000, v, p)));\n"
  "}\n"
  "LOCALFUNC int unpack_lo(int v)\n"
  "{\n"
  "return bitfieldExtract(v, 0, 16);\n"
  "}\n"
  "LOCALFUNC int unpack_hi(int v)\n"
  "{\n"
  "return bitfieldExtract(v, 16, 16);\n"
  "}\n"
  "LOCALFUNC void dc_pred_gradclamp(INOUT_PARA(int, dc), int n, int w, int nw)\n"
  "{\n"
  "#ifdef BUILTIN_MED3\n"
  "int pred = BUILTIN_MED3(n + w - nw, n, w);\n"
  "#else\n"
  "int pred = clamp(n + w - nw, min(n, w), max(n, w));\n"
  "#endif\n"
  "dc = clamp(pred + dc, MININTRA, MAXINTRA);\n"
  "}\n"
  "ROOT_SIGNATURE(RootSigDCPredict)\n"
  "COMPUTE_SHADER_MAIN(NUM_INVOCATIONS, 1, 1)\n"
  "#ifdef METAL_LANG\n"
  ",\n"
  "constant frame_consts& u0 [[ buffer(0) ]],\n"
  "device ivec4 *full_dc_buf [[ buffer(1) ]],\n"
  "device ivec2 *sub_dc_buf [[ buffer(2) ]]\n"
  ")\n"
  "#endif\n"
  "{\n"
  "#ifdef METAL_LANG\n"
  "threadgroup ivec4 edge_dcs[MAX_WIDTH32];\n"
  "#endif\n"
  "uint invoc = gl_LocalInvocationID.x;\n"
  "uint dc_offs = 0;\n"
  "bool is_subsampled = false;\n"
  "switch (gl_WorkGroupID.x)\n"
  "{\n"
  "case 0: dc_offs = U0(dc_offsets).x; is_subsampled = false; break;\n"
  "case 1: dc_offs = U0(dc_offsets).y; is_subsampled = true;  break;\n"
  "case 2: dc_offs = U0(dc_offsets).z; is_subsampled = true;  break;\n"
  "case 3: dc_offs = U0(dc_offsets).w; is_subsampled = false; break;\n"
  "case 4: dc_offs = U0(dc_offsets2).x; is_subsampled = false; break;\n"
  "}\n"
  "uint num_wavefronts = U0(size_in_blocks).x + U0(size_in_blocks).y - 1;\n"
  "if (!is_subsampled)\n"
  "{\n"
  "for (uint wavefront_id = 0; wavefront_id < num_wavefronts; wavefront_id++)\n"
  "{\n"
  "ivec3 edgeNextW = (invoc == 0) ? ivec3(0,0,0) : edge_dcs[invoc-1].yzw;\n"
  "uint base_x = 0;\n"
  "do\n"
  "{\n"
  "uint block_x = base_x + invoc;\n"
  "uint block_y = wavefront_id - block_x;\n"
  "ivec3 edgeW = edgeNextW;\n"
  "ivec2 edgeN = edge_dcs[block_x].xy;\n"
  "#ifndef DC_PREDICT_NO_LOOP\n"
  "edgeNextW = edge_dcs[(block_x + NUM_INVOCATIONS - 1) & (MAX_WIDTH32 - 1)].yzw;\n"
  "#endif\n"
  "group_sync();\n"
  "if (all(lessThan(uvec2(block_x, block_y), U0(size_in_blocks).xy)))\n"
  "{\n"
  "bool is_left = (block_x == 0);\n"
  "bool is_top = bitfieldExtract(U0(flags)[block_y >> 5].x, int(block_y & 31), 1) != 0;\n"
  "int N0 = unpack_lo(edgeN.x);\n"
  "int N1 = unpack_hi(edgeN.x);\n"
  "int N2 = unpack_lo(edgeN.y);\n"
  "int N3 = unpack_hi(edgeN.y);\n"
  "int NW = unpack_lo(edgeW.y);\n"
  "int W0 = unpack_hi(edgeW.y);\n"
  "int W1 = unpack_lo(edgeW.z);\n"
  "int W2 = unpack_hi(edgeW.z);\n"
  "int W3 = unpack_hi(edgeW.x);\n"
  "int dc0,dc1,dc2,dc3,dc4,dc5,dc6,dc7,dc8,dc9,dc10,dc11,dc12,dc13,dc14,dc15;\n"
  "ivec4 v0, v1;\n"
  "uint block_base = (dc_offs + block_y * U0(size_in_blocks).x + block_x) * 2;\n"
  "bool is_intra = read_full_dcs(dc0, dc1, dc2, dc3, dc4, dc5, dc6, dc7, v0, 0, block_base METAL_ARGS);\n"
  "read_full_dcs(dc8, dc9, dc10, dc11, dc12, dc13, dc14, dc15, v1, 1, block_base METAL_ARGS);\n"
  "if (is_intra)\n"
  "{\n"
  "int dc0_W = is_top  ? (is_left ? 1024 : W0) : N0;\n"
  "int dc0_N = is_left ? (is_top  ? 1024 : N0) : W0;\n"
  "int dc0_NW_left  = is_top ? 1024 : N1;\n"
  "int dc0_NW_nleft = is_top ? W1 : NW;\n"
  "int dc0_NW = is_left ? dc0_NW_left : dc0_NW_nleft;\n"
  "dc_pred_gradclamp( dc0, dc0_W, dc0_N, dc0_NW);\n"
  "dc_pred_gradclamp( dc1,  is_top ? dc0 : N1, dc0, is_top ? dc0 : N0);\n"
  "dc_pred_gradclamp( dc2,  dc0, is_left ? dc0 : W1, is_left ? dc1 : W0);\n"
  "dc_pred_gradclamp( dc3,  dc1, dc2, dc0);\n"
  "dc_pred_gradclamp( dc4,  is_top ? dc1 : N2, dc1, is_top ? dc3 : N1);\n"
  "dc_pred_gradclamp( dc5,  is_top ? dc4 : N3, dc4, is_top ? dc4 : N2);\n"
  "dc_pred_gradclamp( dc6,  dc4, dc3, dc1);\n"
  "dc_pred_gradclamp( dc7,  dc5, dc6, dc4);\n"
  "dc_pred_gradclamp( dc8,  dc2, is_left ? dc2 : W2, is_left ? dc3 : W1);\n"
  "dc_pred_gradclamp( dc9,  dc3, dc8, dc2);\n"
  "dc_pred_gradclamp(dc10,  dc8, is_left ? dc8 : W3, is_left ? dc9 : W2);\n"
  "dc_pred_gradclamp(dc11,  dc9, dc10, dc8);\n"
  "dc_pred_gradclamp(dc12,  dc6, dc9, dc3);\n"
  "dc_pred_gradclamp(dc13,  dc7, dc12, dc6);\n"
  "dc_pred_gradclamp(dc14,  dc12, dc11, dc9);\n"
  "dc_pred_gradclamp(dc15,  dc13, dc14, dc12);\n"
  "write_full_dcs(dc0, dc1, dc2, dc3, dc4, dc5, dc6, dc7, v0, 0, block_base METAL_ARGS);\n"
  "write_full_dcs(dc8, dc9, dc10, dc11, dc12, dc13, dc14, dc15, v1, 1, block_base METAL_ARGS);\n"
  "}\n"
  "edge_dcs[block_x].x = pack16(dc10, dc11);\n"
  "edge_dcs[block_x].y = pack16(dc14, dc15);\n"
  "edge_dcs[block_x].z = pack16(N3, dc5);\n"
  "edge_dcs[block_x].w = pack16(dc7, dc13);\n"
  "}\n"
  "group_sync();\n"
  "base_x += NUM_INVOCATIONS;\n"
  "}\n"
  "#ifdef DC_PREDICT_NO_LOOP\n"
  "while (0);\n"
  "#else\n"
  "while (base_x < U0(size_in_blocks).x);\n"
  "#endif\n"
  "}\n"
  "}\n"
  "else\n"
  "{\n"
  "for (uint wavefront_id = 0; wavefront_id < num_wavefronts; wavefront_id++)\n"
  "{\n"
  "ivec3 edgeNextW = (invoc == 0) ? ivec3(0,0,0) : edge_dcs[invoc-1].yzw;\n"
  "uint base_x = 0;\n"
  "do\n"
  "{\n"
  "uint block_x = base_x + invoc;\n"
  "uint block_y = wavefront_id - block_x;\n"
  "ivec3 edgeW = edgeNextW;\n"
  "ivec2 edgeN = edge_dcs[block_x].xy;\n"
  "#ifndef DC_PREDICT_NO_LOOP\n"
  "edgeNextW = edge_dcs[(block_x + NUM_INVOCATIONS - 1) & (MAX_WIDTH32 - 1)].yzw;\n"
  "#endif\n"
  "group_sync();\n"
  "if (all(lessThan(uvec2(block_x, block_y), U0(size_in_blocks).xy)))\n"
  "{\n"
  "bool is_left = (block_x == 0);\n"
  "bool is_top = bitfieldExtract(U0(flags)[block_y >> 5].x, int(block_y & 31), 1) != 0;\n"
  "int N0 = unpack_lo(edgeN.y);\n"
  "int N1 = unpack_hi(edgeN.y);\n"
  "int NW = unpack_lo(edgeW.y);\n"
  "int W0 = unpack_hi(edgeW.y);\n"
  "int W1 = unpack_hi(edgeW.x);\n"
  "int dc0, dc1, dc2, dc3;\n"
  "ivec2 v;\n"
  "uint block_base = dc_offs + block_y * U0(size_in_blocks).x + block_x;\n"
  "bool is_intra = read_sub_dcs(dc0, dc1, dc2, dc3, v, block_base METAL_ARGS);\n"
  "if (is_intra)\n"
  "{\n"
  "int dc0_W = is_top  ? (is_left ? 1024 : W0) : N0;\n"
  "int dc0_N = is_left ? (is_top  ? 1024 : N0) : W0;\n"
  "int dc0_NW_left  = is_top ? 1024 : N1;\n"
  "int dc0_NW_nleft = is_top ? W1 : NW;\n"
  "int dc0_NW = is_left ? dc0_NW_left : dc0_NW_nleft;\n"
  "dc_pred_gradclamp( dc0, dc0_W, dc0_N, dc0_NW);\n"
  "dc_pred_gradclamp( dc1,  is_top ? dc0 : N1, dc0, is_top ? dc0 : N0);\n"
  "dc_pred_gradclamp( dc2,  dc0, is_left ? dc0 : W1, is_left ? dc1 : W0);\n"
  "dc_pred_gradclamp( dc3,  dc1, dc2, dc0);\n"
  "write_sub_dcs(dc0, dc1, dc2, dc3, v, block_base METAL_ARGS);\n"
  "}\n"
  "edge_dcs[block_x].y = pack16(dc2, dc3);\n"
  "edge_dcs[block_x].z = pack16(N1, dc1);\n"
  "}\n"
  "group_sync();\n"
  "base_x += NUM_INVOCATIONS;\n"
  "}\n"
  "#ifdef DC_PREDICT_NO_LOOP\n"
  "while (0);\n"
  "#else\n"
  "while (base_x < U0(size_in_blocks).x);\n"
  "#endif\n"
  "}\n"
  "}\n"
  "}\n";

#define NUMFRAGMENTS_cshader_dc_predict 4
static char const * const cshader_dc_predict[1][NUMFRAGMENTS_cshader_dc_predict] = {
   { shader_source_frag0, shader_source_frag2, shader_source_frag3, shader_source_frag7, },
};

static char const shader_source_frag8[] =
  "DECLARE_IMAGE_R8UI_2D(0, o_img);\n"
  "DECLARE_SAMPLER_IBUF(0, ivec2, motion);\n"
  "DECLARE_SAMPLER_IBUF(1, int1, dc_data);\n"
  "#ifdef DEBLOCK_FROM_BUF\n"
  "DECLARE_SAMPLER_IBUF(2, int1, fetch_buf);\n"
  "#else\n"
  "#ifndef NO_DEBLOCK_INPUT_SAMPLER\n"
  "DECLARE_SAMPLER_U2D(2, i_img);\n"
  "#endif\n"
  "#endif\n"
  "#define MASK_LOW_X 0x5\n"
  "#define MASK_LOW_Y 0xa\n"
  "#define MASK_BLOCK ~0xf\n"
  "#define MASK_ALL_X (MASK_LOW_X | MASK_BLOCK)\n"
  "#define MASK_ALL_Y (MASK_LOW_Y | MASK_BLOCK)\n"
  "SHARED_GLOBAL(uint, strengths[64]);\n"
  "#define METAL_ARGD METAL_ARG(device short1 *dc_data)\n"
  "#define METAL_ARGS METAL_ARG(dc_data)\n"
  "LOCALFUNC uint morton_decode(uint x)\n"
  "{\n"
  "return (x & 1) | ((x >> 1) & 2);\n"
  "}\n"
  "LOCALFUNC uvec2 block_id_to_pos(uint id)\n"
  "{\n"
  "return uvec2(morton_decode(id >> 0), morton_decode(id >> 1));\n"
  "}\n"
  "LOCALFUNC int get_dc(uint x_offs, uint y_offs METAL_ARGD)\n"
  "{\n"
  "return bufferFetch(dc_data, int(x_offs + y_offs)).x;\n"
  "}\n"
  "ROOT_SIGNATURE(RootSigDeblock)\n"
  "COMPUTE_SHADER_MAIN(64, 1, 1)\n"
  "#ifdef METAL_LANG\n"
  ",\n"
  "constant frame_consts& u0 [[ buffer(0) ]],\n"
  "constant deblock_consts& u1 [[ buffer(1) ]],\n"
  "device short2 *motion [[ buffer(2) ]],\n"
  "device short1 *dc_data [[ buffer(3) ]],\n"
  "device uint1 *fetch_buf [[ buffer(4) ]],\n"
  "rwtexture2d_ushort o_img [[ texture(0) ]]\n"
  ")\n"
  "#endif\n"
  "{\n"
  "#ifdef METAL_LANG\n"
  "threadgroup uint strengths[64];\n"
  "#endif\n"
  "uint invoc = gl_LocalInvocationID.x;\n"
  "uint block_id = invoc & 15;\n"
  "uvec2 group_id = (gl_WorkGroupID.xy << 1) + uvec2((invoc >> 4) & 1, invoc >> 5);\n"
  "uint x_offs0 = group_id.x * 16 + (block_id & MASK_LOW_X);\n"
  "uint y_offs0 = group_id.y * (U0(size_in_blocks).x * 16) + (block_id & MASK_LOW_Y);\n"
  "uint x_offs1 = (x_offs0 - (MASK_ALL_X & U1(dir_mask).x)) & MASK_ALL_X;\n"
  "uint y_offs1 = (y_offs0 - (MASK_ALL_Y & U1(dir_mask).y)) & MASK_ALL_Y;\n"
  "y_offs1 += ((y_offs1 & MASK_LOW_Y) == 0) ? U1(row_inc_full) : 0;\n"
  "int dcf0 = min(get_dc(x_offs0, y_offs0 METAL_ARGS), 0);\n"
  "int dcf1 = min(get_dc(x_offs1, y_offs1 METAL_ARGS), 0);\n"
  "uint str = (uint(dcf0) >> 13) & 3;\n"
  "str |= (uint(dcf1) >> 11) & (3<<2);\n"
  "if ((dcf0 | dcf1) >= 0)\n"
  "{\n"
  "uint mv_offs0 = (x_offs0 + y_offs0) >> 2;\n"
  "uint mv_offs1 = (x_offs1 + y_offs1) >> 2;\n"
  "if (mv_offs0 != mv_offs1)\n"
  "{\n"
  "ivec2 mot0 = ivec2(bufferFetch(motion, int(mv_offs0)).xy);\n"
  "ivec2 mot1 = ivec2(bufferFetch(motion, int(mv_offs1)).xy);\n"
  "uvec2 diff_mv = uvec2(1, 1) + uvec2(mot1 - mot0);\n"
  "str = any(greaterThan(diff_mv, uvec2(2, 2))) ? (2 << 2) | 2 : 0;\n"
  "}\n"
  "}\n"
  "uvec2 block_pos = group_id.xy * 4 + block_id_to_pos(block_id);\n"
  "uint nodeblock_idx = (block_pos.x & U1(dir_mask).x) + (block_pos.y & U1(dir_mask).y);\n"
  "uvec2 nodeblock_bits = U0(flags)[nodeblock_idx >> 5].yz;\n"
  "uint nodeblock_flag = (nodeblock_bits.x & U1(dir_mask).x) | (nodeblock_bits.y & U1(dir_mask).y);\n"
  "bool nodeblock = bitfieldExtract(nodeblock_flag, int(nodeblock_idx & 31), 1) != 0;\n"
  "nodeblock = nodeblock || any(greaterThan(uvec2(x_offs1, y_offs1), U0(max_offs_full)));\n"
  "nodeblock = nodeblock || str == 15;\n"
  "strengths[invoc] = nodeblock ? 0 : str;\n"
  "group_sync();\n"
  "for (int base_block = 0; base_block < 64; base_block += 8)\n"
  "{\n"
  "int sum_block_id = base_block + int(invoc >> 3);\n"
  "str = strengths[sum_block_id];\n"
  "if (str == 0)\n"
  "continue;\n"
  "uint str0 = str & 3;\n"
  "uint str1 = str >> 2;\n"
  "uvec2 mblock_xy = (gl_WorkGroupID.xy << 1) + uvec2((sum_block_id >> 4) & 1, sum_block_id >> 5);\n"
  "uint edge_along = invoc & 7;\n"
  "ivec2 edge_pos = ivec2(mblock_xy) << 5;\n"
  "edge_pos += ivec2(block_id_to_pos(sum_block_id & 15)) << 3;\n"
  "edge_pos += ivec2(edge_along, edge_along) & ~ivec2(U1(dir_mask));\n"
  "#ifdef DEBLOCK_FROM_BUF\n"
  "uint block_offs = ((mblock_xy.y * U0(size_in_blocks).x + mblock_xy.x) << 4) | (sum_block_id & 15);\n"
  "uint in_texels = uint(bufferFetch(fetch_buf, (block_offs << 3) | edge_along).x);\n"
  "int p0 = int((in_texels >>  0) & 0xff);\n"
  "int p1 = int((in_texels >>  8) & 0xff);\n"
  "int p2 = int((in_texels >> 16) & 0xff);\n"
  "int p3 = int((in_texels >> 24) & 0xff);\n"
  "#else\n"
  "int p0 = int(texelOrImageFetch(i_img, o_img, edge_pos + (ivec2(6,6) & ivec2(U1(dir_mask)))).x);\n"
  "int p1 = int(texelOrImageFetch(i_img, o_img, edge_pos + (ivec2(7,7) & ivec2(U1(dir_mask)))).x);\n"
  "int p2 = int(texelOrImageFetch(i_img, o_img, edge_pos + (ivec2(8,8) & ivec2(U1(dir_mask)))).x);\n"
  "int p3 = int(texelOrImageFetch(i_img, o_img, edge_pos + (ivec2(9,9) & ivec2(U1(dir_mask)))).x);\n"
  "#endif\n"
  "int diff = p2 - p1;\n"
  "int delta_near = (diff + 2) >> 2;\n"
  "int delta_far = (diff + 4) >> 3;\n"
  "p0 = (str0 >= 2) ? clamp(p0 + delta_far,  0, 255) : p0;\n"
  "p1 = (str0 >= 1) ? clamp(p1 + delta_near, 0, 255) : p1;\n"
  "p2 = (str1 >= 1) ? clamp(p2 - delta_near, 0, 255) : p2;\n"
  "p3 = (str1 >= 2) ? clamp(p3 - delta_far,  0, 255) : p3;\n"
  "imageStore_u1(o_img, edge_pos + (ivec2(6,6) & ivec2(U1(dir_mask))), p0);\n"
  "imageStore_u1(o_img, edge_pos + (ivec2(7,7) & ivec2(U1(dir_mask))), p1);\n"
  "imageStore_u1(o_img, edge_pos + (ivec2(8,8) & ivec2(U1(dir_mask))), p2);\n"
  "imageStore_u1(o_img, edge_pos + (ivec2(9,9) & ivec2(U1(dir_mask))), p3);\n"
  "}\n"
  "}\n";

#define NUMFRAGMENTS_cshader_deblock_full_plane 5
static char const * const cshader_deblock_full_plane[2][NUMFRAGMENTS_cshader_deblock_full_plane] = {
   { shader_source_frag0, shader_source_frag1, shader_source_frag2, shader_source_frag3, shader_source_frag8, },
   { NULL, NULL, NULL, NULL, NULL, },
};

static char const shader_source_frag9[] =
  "DECLARE_IMAGE_RG8UI_2D(0, o_img);\n"
  "DECLARE_SAMPLER_IBUF(0, ivec2, motion);\n"
  "DECLARE_SAMPLER_IBUF(1, int1, dc_data);\n"
  "#ifdef DEBLOCK_FROM_BUF\n"
  "DECLARE_SAMPLER_IBUF(2, int1, fetch_buf);\n"
  "#else\n"
  "#ifndef NO_DEBLOCK_INPUT_SAMPLER\n"
  "DECLARE_SAMPLER_U2D(2, i_img);\n"
  "#endif\n"
  "#endif\n"
  "#define MASK_LOW_X 0x1\n"
  "#define MASK_LOW_Y 0x2\n"
  "#define MASK_BLOCK ~0x3\n"
  "#define MASK_ALL_X (MASK_LOW_X | MASK_BLOCK)\n"
  "#define MASK_ALL_Y (MASK_LOW_Y | MASK_BLOCK)\n"
  "SHARED_GLOBAL(uint, strengths[32]);\n"
  "#define METAL_ARGD METAL_ARG(device short1 *dc_data)\n"
  "#define METAL_ARGS METAL_ARG(dc_data)\n"
  "LOCALFUNC uvec2 block_id_to_pos(uint id)\n"
  "{\n"
  "return uvec2(id & 1, (id >> 1));\n"
  "}\n"
  "LOCALFUNC int get_dc(uint x_offs, uint y_offs METAL_ARGD)\n"
  "{\n"
  "return bufferFetch(dc_data, int(x_offs + y_offs)).x;\n"
  "}\n"
  "ROOT_SIGNATURE(RootSigDeblock)\n"
  "COMPUTE_SHADER_MAIN(64, 1, 1)\n"
  "#ifdef METAL_LANG\n"
  ",\n"
  "constant frame_consts& u0 [[ buffer(0) ]],\n"
  "constant deblock_consts& u1 [[ buffer(1) ]],\n"
  "device short2 *motion [[ buffer(2) ]],\n"
  "device short1 *dc_data [[ buffer(3) ]],\n"
  "device uint1 *fetch_buf [[ buffer(4) ]],\n"
  "rwtexture2d_ushort o_img [[ texture(0) ]]\n"
  ")\n"
  "#endif\n"
  "{\n"
  "#ifdef METAL_LANG\n"
  "threadgroup uint strengths[32];\n"
  "#endif\n"
  "uint invoc = gl_LocalInvocationID.x;\n"
  "if (invoc < 32)\n"
  "{\n"
  "uint block_id = invoc & 3;\n"
  "uvec2 group_id = (gl_WorkGroupID.xy << 1) | uvec2((invoc >> 2) & 1, (invoc >> 3) & 1);\n"
  "uint plane_offs = (invoc >= 16) ? U0(cb_offs_dc) : 0;\n"
  "uint x_offs0 = group_id.x * 4 + (block_id & MASK_LOW_X);\n"
  "uint y_offs0 = group_id.y * (U0(size_in_blocks).x * 4) + (block_id & MASK_LOW_Y);\n"
  "uint x_offs1 = (x_offs0 - (MASK_ALL_X & U1(dir_mask).x)) & MASK_ALL_X;\n"
  "uint y_offs1 = (y_offs0 - (MASK_ALL_Y & U1(dir_mask).y)) & MASK_ALL_Y;\n"
  "y_offs1 += ((y_offs1 & MASK_LOW_Y) == 0) ? U1(row_inc_sub) : 0;\n"
  "int dcf0 = min(get_dc(x_offs0, y_offs0 + plane_offs METAL_ARGS), 0);\n"
  "int dcf1 = min(get_dc(x_offs1, y_offs1 + plane_offs METAL_ARGS), 0);\n"
  "uint str = (uint(dcf0) >> 13) & 3;\n"
  "str |= (uint(dcf1) >> 11) & (3<<2);\n"
  "if ((dcf0 | dcf1) >= 0)\n"
  "{\n"
  "ivec2 mot0 = ivec2(bufferFetch(motion, int(x_offs0 + y_offs0)).xy);\n"
  "ivec2 mot1 = ivec2(bufferFetch(motion, int(x_offs1 + y_offs1)).xy);\n"
  "uvec2 diff_mv = uvec2(1, 1) + uvec2(mot1 - mot0);\n"
  "str = any(greaterThan(diff_mv, uvec2(2, 2))) ? (2 << 2) | 2 : 0;\n"
  "}\n"
  "uvec2 block_pos = group_id.xy * 2 + block_id_to_pos(block_id);\n"
  "uint nodeblock_idx = ((block_pos.x & U1(dir_mask).x) + (block_pos.y & U1(dir_mask).y)) * 2 + 1;\n"
  "uvec2 nodeblock_bits = U0(flags)[nodeblock_idx >> 5].yz;\n"
  "uint nodeblock_flag = (nodeblock_bits.x & U1(dir_mask).x) | (nodeblock_bits.y & U1(dir_mask).y);\n"
  "bool nodeblock = bitfieldExtract(nodeblock_flag, int(nodeblock_idx & 31), 1) != 0;\n"
  "nodeblock = nodeblock || any(greaterThan(uvec2(x_offs1, y_offs1), U0(max_offs_sub)));\n"
  "nodeblock = nodeblock || str == 15;\n"
  "strengths[invoc] = nodeblock ? 0 : str;\n"
  "}\n"
  "group_sync();\n"
  "for (int base_block = 0; base_block < 16; base_block += 8)\n"
  "{\n"
  "int sum_block_id = base_block + int(invoc >> 3);\n"
  "uint str_x = strengths[sum_block_id];\n"
  "uint str_y = strengths[sum_block_id + 16];\n"
  "if ((str_x | str_y) == 0)\n"
  "continue;\n"
  "uint str0_x = str_x & 3;\n"
  "uint str1_x = str_x >> 2;\n"
  "uint str0_y = str_y & 3;\n"
  "uint str1_y = str_y >> 2;\n"
  "uvec2 mblock_xy = (gl_WorkGroupID.xy << 1) | uvec2((sum_block_id >> 2) & 1, (sum_block_id >> 3) & 1);\n"
  "uint edge_along = invoc & 7;\n"
  "ivec2 edge_pos = ivec2(mblock_xy) << 4;\n"
  "edge_pos += ivec2(block_id_to_pos(sum_block_id & 3)) << 3;\n"
  "edge_pos += ivec2(edge_along, edge_along) & ~ivec2(U1(dir_mask));\n"
  "#ifdef DEBLOCK_FROM_BUF\n"
  "uint block_offs = ((mblock_xy.y * U0(size_in_blocks).x + mblock_xy.x) << 2) | (sum_block_id & 3);\n"
  "uint fetch_offs = (block_offs << 3) | edge_along;\n"
  "uvec2 in_texels;\n"
  "in_texels.x = uint(bufferFetch(fetch_buf, fetch_offs).x);\n"
  "in_texels.y = uint(bufferFetch(fetch_buf, fetch_offs + (U0(cb_offs_dc) << 3)).x);\n"
  "ivec2 p0 = ivec2((in_texels >>  0) & 0xff);\n"
  "ivec2 p1 = ivec2((in_texels >>  8) & 0xff);\n"
  "ivec2 p2 = ivec2((in_texels >> 16) & 0xff);\n"
  "ivec2 p3 = ivec2((in_texels >> 24) & 0xff);\n"
  "#else\n"
  "ivec2 p0 = ivec2(texelOrImageFetch(i_img, o_img, edge_pos + (ivec2(6,6) & ivec2(U1(dir_mask)))).xy);\n"
  "ivec2 p1 = ivec2(texelOrImageFetch(i_img, o_img, edge_pos + (ivec2(7,7) & ivec2(U1(dir_mask)))).xy);\n"
  "ivec2 p2 = ivec2(texelOrImageFetch(i_img, o_img, edge_pos + (ivec2(8,8) & ivec2(U1(dir_mask)))).xy);\n"
  "ivec2 p3 = ivec2(texelOrImageFetch(i_img, o_img, edge_pos + (ivec2(9,9) & ivec2(U1(dir_mask)))).xy);\n"
  "#endif\n"
  "ivec2 diff = p2 - p1;\n"
  "ivec2 delta_near = (diff + 2) >> 2;\n"
  "ivec2 delta_far = (diff + 4) >> 3;\n"
  "p0.x = (str0_x >= 2) ? clamp(p0.x + delta_far.x,  0, 255) : p0.x;\n"
  "p1.x = (str0_x >= 1) ? clamp(p1.x + delta_near.x, 0, 255) : p1.x;\n"
  "p2.x = (str1_x >= 1) ? clamp(p2.x - delta_near.x, 0, 255) : p2.x;\n"
  "p3.x = (str1_x >= 2) ? clamp(p3.x - delta_far.x,  0, 255) : p3.x;\n"
  "p0.y = (str0_y >= 2) ? clamp(p0.y + delta_far.y,  0, 255) : p0.y;\n"
  "p1.y = (str0_y >= 1) ? clamp(p1.y + delta_near.y, 0, 255) : p1.y;\n"
  "p2.y = (str1_y >= 1) ? clamp(p2.y - delta_near.y, 0, 255) : p2.y;\n"
  "p3.y = (str1_y >= 2) ? clamp(p3.y - delta_far.y,  0, 255) : p3.y;\n"
  "imageStore_u2(o_img, edge_pos + (ivec2(6,6) & ivec2(U1(dir_mask))), uvec2(p0));\n"
  "imageStore_u2(o_img, edge_pos + (ivec2(7,7) & ivec2(U1(dir_mask))), uvec2(p1));\n"
  "imageStore_u2(o_img, edge_pos + (ivec2(8,8) & ivec2(U1(dir_mask))), uvec2(p2));\n"
  "imageStore_u2(o_img, edge_pos + (ivec2(9,9) & ivec2(U1(dir_mask))), uvec2(p3));\n"
  "}\n"
  "}\n";

#define NUMFRAGMENTS_cshader_deblock_sub_plane 5
static char const * const cshader_deblock_sub_plane[2][NUMFRAGMENTS_cshader_deblock_sub_plane] = {
   { shader_source_frag0, shader_source_frag1, shader_source_frag2, shader_source_frag3, shader_source_frag9, },
   { NULL, NULL, NULL, NULL, NULL, },
};

static char const shader_source_frag10[] =
  "DECLARE_IMAGE_R8UI_2D(0, o_img);\n"
  "ROOT_SIGNATURE(RootSigFillAlpha)\n"
  "COMPUTE_SHADER_MAIN(8, 8, 1)\n"
  "#ifdef METAL_LANG\n"
  ",\n"
  "constant frame_consts& u0 [[ buffer(0) ]],\n"
  "rwtexture2d_ushort o_img [[ texture(0) ]]\n"
  ")\n"
  "#endif\n"
  "{\n"
  "uvec2 group_id = gl_WorkGroupID.xy;\n"
  "uvec2 invoc = gl_LocalInvocationID.xy;\n"
  "imageStore_u1(o_img, (group_id * 8)+invoc, U0(fill_alpha_value));\n"
  "}\n";

#define NUMFRAGMENTS_cshader_fill_alpha_plane 4
static char const * const cshader_fill_alpha_plane[1][NUMFRAGMENTS_cshader_fill_alpha_plane] = {
   { shader_source_frag0, shader_source_frag2, shader_source_frag3, shader_source_frag10, },
};

static char const shader_source_frag11[] =
  "UNIFORM_BUFFER(consts, 0) {\n"
  "vec4 xy_transform[2];\n"
  "vec4 uv_transform[3];\n"
  "vec4 tex_size;\n"
  "vec4 tex_clamp;\n"
  "vec4 alpha_mult;\n"
  "vec4 cmatrix[4];\n"
  "vec4 hdr;\n"
  "vec4 ctcp;\n"
  "};\n"
  "layout(binding=0) uniform sampler2D texY;\n"
  "layout(binding=1) uniform sampler2D texCrCb;\n"
  "layout(binding=2) uniform sampler2D texA;\n"
  "layout(location=0) in vec4 v_texcoords;\n"
  "out vec4 out_color;\n"
  "void main()\n"
  "{\n"
  "vec2 tex_full = clamp(v_texcoords.xy, tex_clamp.xy, tex_size.xy - tex_clamp.xy);\n"
  "vec2 tex_sub = clamp(v_texcoords.zw, tex_clamp.zw, tex_size.zw - tex_clamp.zw);\n"
  "float Y = texture(texY, tex_full).x;\n"
  "vec2  CrCb = texture(texCrCb, tex_sub).xy;\n"
  "float A = texture(texA, tex_full).x;\n"
  "vec3 rgb = Y*cmatrix[3].xyz + CrCb.x*cmatrix[0].xyz + CrCb.y*cmatrix[1].xyz + cmatrix[2].xyz;\n"
  "out_color = vec4(rgb, A) * alpha_mult;\n"
  "}\n";

#define NUMFRAGMENTS_pshader_draw_gl 2
static char const * const pshader_draw_gl[1][NUMFRAGMENTS_pshader_draw_gl] = {
   { shader_source_frag0, shader_source_frag11, },
};

static char const shader_source_frag12[] =
  "UNIFORM_BUFFER(consts, 0) {\n"
  "vec4 xy_transform[2];\n"
  "vec4 uv_transform[3];\n"
  "vec4 tex_size;\n"
  "vec4 tex_clamp;\n"
  "vec4 alpha_mult;\n"
  "vec4 cmatrix[4];\n"
  "vec4 hdr;\n"
  "vec4 ctcp;\n"
  "};\n"
  "layout(location=0) out vec4 v_texcoords;\n"
  "void main()\n"
  "{\n"
  "vec2 st = vec2(gl_VertexID & 1, gl_VertexID >> 1);\n"
  "gl_Position.xy = st.x*xy_transform[0].xz + st.y*xy_transform[0].yw + xy_transform[1].xy;\n"
  "gl_Position.zw = vec2(0.0, 1.0);\n"
  "v_texcoords = st.x*uv_transform[0] + st.y*uv_transform[1] + uv_transform[2];\n"
  "}\n";

#define NUMFRAGMENTS_vshader_draw_gl 2
static char const * const vshader_draw_gl[1][NUMFRAGMENTS_vshader_draw_gl] = {
   { shader_source_frag0, shader_source_frag12, },
};

static char const shader_source_frag13[] =
  "UNIFORM_BUFFER(consts, 0) {\n"
  "vec4 xy_transform[2];\n"
  "vec4 uv_transform[3];\n"
  "vec4 tex_size;\n"
  "vec4 tex_clamp;\n"
  "vec4 alpha_mult;\n"
  "vec4 cmatrix[4];\n"
  "vec4 hdr;\n"
  "vec4 ctcp;\n"
  "};\n"
  "layout(binding=0) uniform sampler2D texI0;\n"
  "layout(binding=1) uniform sampler2D texCtCp;\n"
  "layout(binding=2) uniform sampler2D texA;\n"
  "layout(binding=3) uniform sampler2D texI1;\n"
  "layout(location=0) in vec4 v_texcoords;\n"
  "out vec4 out_color;\n"
  "void main()\n"
  "{\n"
  "vec2 tex_full = clamp(v_texcoords.xy, tex_clamp.xy, tex_size.xy - tex_clamp.xy);\n"
  "vec2 tex_sub = clamp(v_texcoords.zw, tex_clamp.zw, tex_size.zw - tex_clamp.zw);\n"
  "float I0 = texture(texI0, tex_full).x;\n"
  "vec2  CtCp = texture(texCtCp, tex_sub).xy;\n"
  "float A = texture(texA, tex_full).x;\n"
  "float I1 = texture(texI1, tex_full).x;\n"
  "CtCp.x = CtCp.x * ctcp.x + ctcp.z;\n"
  "CtCp.y = CtCp.y * ctcp.y + ctcp.w;\n"
  "vec3 LMS = (I0 + I1) * hdr.xxx;\n"
  "LMS += CtCp.x * vec3(0.00860903703793281, -0.00860903703793281, 0.56003133571067909);\n"
  "LMS += CtCp.y * vec3(0.11102962500302593, -0.11102962500302593, -0.32062717498731880);\n"
  "LMS = max(LMS, 0.0);\n"
  "LMS = pow(LMS, vec3(1.0/(2523.0/4096.0*128.0)));\n"
  "vec3 num = max(LMS - (3424.0/4096.0), 0.0);\n"
  "vec3 denom = (2413.0/4096.0*32.0) - (2392.0/4096.0*32.0) * LMS;\n"
  "LMS = pow(abs(num / denom), vec3(1.0/(2610.0/16384.0)));\n"
  "vec3 rgb = LMS.x * (vec3(3.4366066943330793, -0.7913295555989289, -0.0259498996905927) * 125.0);\n"
  "rgb += LMS.y * (vec3(-2.5064521186562705, 1.9836004517922909, -0.0989137147117265) * 125.0);\n"
  "rgb += LMS.z * (vec3(0.0698454243231915, -0.1922708961933620, 1.1248636144023192) * 125.0);\n"
  "vec4 p = vec4(rgb * hdr.y, A);\n"
  "#ifdef TONEMAP\n"
  "p.xyz /= p.xyz+1;\n"
  "p.xyz *= hdr.z;\n"
  "#endif\n"
  "#ifdef ST2084\n"
  "vec3 Lm1 = pow(p.xyz*(1.0/125), vec3(0.159301758125));\n"
  "vec3 X = (0.8359375 + 18.8515625 * Lm1) / (1 + 18.6875 * Lm1);\n"
  "p.xyz = pow(X, vec3(78.84375));\n"
  "#endif\n"
  "out_color = p * alpha_mult;\n"
  "}\n";
static char const shader_source_frag14[] =
  "#define ST2084\n";
static char const shader_source_frag15[] =
  "#define TONEMAP\n";

#define NUMFRAGMENTS_pshader_draw_pixel_ictcp_gl 4
static char const * const pshader_draw_pixel_ictcp_gl[4][NUMFRAGMENTS_pshader_draw_pixel_ictcp_gl] = {
   { shader_source_frag0, shader_source_frag1, shader_source_frag1, shader_source_frag13, },
   { shader_source_frag0, shader_source_frag1, shader_source_frag14, shader_source_frag13, },
   { shader_source_frag0, shader_source_frag15, shader_source_frag1, shader_source_frag13, },
   { shader_source_frag0, shader_source_frag15, shader_source_frag14, shader_source_frag13, },
};

